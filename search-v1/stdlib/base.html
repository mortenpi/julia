<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Essentials Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li class="current"><a class="toctext" href="base.html">Essentials</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Getting-Around-1">Getting Around</a></li><li><a class="toctext" href="#All-Objects-1">All Objects</a></li><li><a class="toctext" href="#Dealing-with-Types-1">Dealing with Types</a></li><li><a class="toctext" href="#Special-Types-1">Special Types</a></li><li><a class="toctext" href="#Generic-Functions-1">Generic Functions</a></li><li><a class="toctext" href="#Syntax-1">Syntax</a></li><li><a class="toctext" href="#Nullables-1">Nullables</a></li><li><a class="toctext" href="#System-1">System</a></li><li><a class="toctext" href="#Errors-1">Errors</a></li><li><a class="toctext" href="#Events-1">Events</a></li><li><a class="toctext" href="#Reflection-1">Reflection</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li></ul></li><li><a class="toctext" href="collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Numbers</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="file.html">Filesystem</a></li><li><a class="toctext" href="io-network.html">I/O and Network</a></li><li><a class="toctext" href="punctuation.html">Punctuation</a></li><li><a class="toctext" href="sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="dates.html">Dates and Time</a></li><li><a class="toctext" href="iterators.html">Iteration utilities</a></li><li><a class="toctext" href="test.html">Unit Testing</a></li><li><a class="toctext" href="c.html">C Interface</a></li><li><a class="toctext" href="libc.html">C Standard Library</a></li><li><a class="toctext" href="libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">StackTraces</a></li><li><a class="toctext" href="simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href="base.html">Essentials</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/doc/src/stdlib/base.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Essentials</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Essentials-1" href="#Essentials-1">Essentials</a></h1><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>The Julia standard library contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages.  Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.</p><p>Some general notes:</p><ul><li><p>Except for functions in built-in modules (<code>Pkg</code>, <code>Collections</code>, <code>Test</code> and <code>Profile</code>), all functions documented here are directly available for use in programs.</p></li><li><p>To use module functions, use <code>import Module</code> to import the module, and <code>Module.fn(x)</code> to use the functions.</p></li><li><p>Alternatively, <code>using Module</code> will import all exported <code>Module</code> functions into the current namespace.</p></li><li><p>By convention, function names ending with an exclamation point (<code>!</code>) modify their arguments. Some functions have both modifying (e.g., <code>sort!</code>) and non-modifying (<code>sort</code>) versions.</p></li></ul><h2><a class="nav-anchor" id="Getting-Around-1" href="#Getting-Around-1">Getting Around</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exit" href="#Base.exit"><code>Base.exit</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">exit(code=0)</code></pre><p>Quit the program with an exit code. The default exit code is zero, indicating that the program completed successfully (see also <a href="base.html#Base.quit"><code>quit</code></a>). In an interactive session, <code>exit()</code> can be called with the keyboard shorcut <code>^D</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/initdefs.jl#L21-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.quit" href="#Base.quit"><code>Base.quit</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">quit()</code></pre><p>Quit the program indicating successful completion. This function is equivalent to <code>exit(0)</code> (see <a href="base.html#Base.exit"><code>exit</code></a>). In an interactive session, <code>quit()</code> can be called with the keyboard shorcut <code>^D</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/initdefs.jl#L32-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atexit" href="#Base.atexit"><code>Base.atexit</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atexit(f)</code></pre><p>Register a zero-argument function <code>f()</code> to be called at process exit. <code>atexit()</code> hooks are called in last in first out (LIFO) order and run before object finalizers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/initdefs.jl#L102-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atreplinit" href="#Base.atreplinit"><code>Base.atreplinit</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atreplinit(f)</code></pre><p>Register a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of <code>f</code> is the REPL object. This function should be called from within the <code>.juliarc.jl</code> initialization file.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/client.jl#L363-L370">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isinteractive" href="#Base.isinteractive"><code>Base.isinteractive</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isinteractive() -&gt; Bool</code></pre><p>Determine whether Julia is running an interactive session.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/initdefs.jl#L45-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.whos" href="#Base.whos"><code>Base.whos</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">whos(io::IO=STDOUT, m::Module=Main, pattern::Regex=r&quot;&quot;)</code></pre><p>Print information about exported global variables in a module, optionally restricted to those matching <code>pattern</code>.</p><p>The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L730-L736">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summarysize" href="#Base.summarysize"><code>Base.summarysize</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -&gt; Int</code></pre><p>Compute the amount of memory used by all unique objects reachable from the argument.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>exclude</code>: specifies the types of objects to exclude from the traversal.</p></li><li><p><code>chargeall</code>: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/summarysize.jl#L13-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.edit-Tuple{AbstractString,Integer}" href="#Base.edit-Tuple{AbstractString,Integer}"><code>Base.edit</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">edit(path::AbstractString, line::Integer=0)</code></pre><p>Edit a file or directory optionally providing a line number to edit the file at. Returns to the <code>julia</code> prompt when you quit the editor. The editor can be changed by setting <code>JULIA_EDITOR</code>, <code>VISUAL</code> or <code>EDITOR</code> as an environment variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L26-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.edit-Tuple{Any}" href="#Base.edit-Tuple{Any}"><code>Base.edit</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">edit(function, [types])</code></pre><p>Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. The editor can be changed by setting <code>JULIA_EDITOR</code>, <code>VISUAL</code> or <code>EDITOR</code> as an environment variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L83-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@edit" href="#Base.@edit"><code>Base.@edit</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@edit</code></pre><p>Evaluates the arguments to the function or macro call, determines their types, and calls the <code>edit</code> function on the resulting expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L498-L503">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.less-Tuple{AbstractString}" href="#Base.less-Tuple{AbstractString}"><code>Base.less</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">less(file::AbstractString, [line::Integer])</code></pre><p>Show a file using the default pager, optionally providing a starting line number. Returns to the <code>julia</code> prompt when you quit the pager.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L109-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.less-Tuple{Any}" href="#Base.less-Tuple{Any}"><code>Base.less</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">less(function, [types])</code></pre><p>Show the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L117-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@less" href="#Base.@less"><code>Base.@less</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@less</code></pre><p>Evaluates the arguments to the function or macro call, determines their types, and calls the <code>less</code> function on the resulting expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L490-L495">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.clipboard-Tuple{Any}" href="#Base.clipboard-Tuple{Any}"><code>Base.clipboard</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">clipboard(x)</code></pre><p>Send a printed form of <code>x</code> to the operating system clipboard (&quot;copy&quot;).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L206-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.clipboard-Tuple{}" href="#Base.clipboard-Tuple{}"><code>Base.clipboard</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">clipboard() -&gt; AbstractString</code></pre><p>Return a string with the contents of the operating system clipboard (&quot;paste&quot;).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L213-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reload" href="#Base.reload"><code>Base.reload</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reload(name::AbstractString)</code></pre><p>Force reloading of a package, even if it has been loaded before. This is intended for use during package development as code is modified.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L279-L284">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.require" href="#Base.require"><code>Base.require</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">require(module::Symbol)</code></pre><p>This function is part of the implementation of <code>using</code> / <code>import</code>, if a module is not already defined in <code>Main</code>. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</p><p>Loads a source file, in the context of the <code>Main</code> module, on every active node, searching standard locations for files. <code>require</code> is considered a top-level operation, so it sets the current <code>include</code> path but does not use it to search for files (see help for <code>include</code>). This function is typically used to load library code, and is implicitly called by <code>using</code> to load packages.</p><p>When searching for files, <code>require</code> first looks for package code under <code>Pkg.dir()</code>, then tries paths in the global array <code>LOAD_PATH</code>. <code>require</code> is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L299-L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.compilecache" href="#Base.compilecache"><code>Base.compilecache</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.compilecache(module::String)</code></pre><p>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in <code>LOAD_CACHE_PATH[1]</code>, which defaults to <code>~/.julia/lib/VERSION</code>. See <a href="../manual/modules.html#Module-initialization-and-precompilation-1">Module initialization and precompilation</a> for important notes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L612-L621">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.__precompile__" href="#Base.__precompile__"><code>Base.__precompile__</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">__precompile__(isprecompilable::Bool=true)</code></pre><p>Specify whether the file calling this function is precompilable. If <code>isprecompilable</code> is <code>true</code>, then <code>__precompile__</code> throws an exception when the file is loaded by <code>using</code>/<code>import</code>/<code>require</code> <em>unless</em> the file is being precompiled, and in a module file it causes the module to be automatically precompiled when it is imported. Typically, <code>__precompile__()</code> should occur before the <code>module</code> declaration in the file.</p><p>If a module or file is <em>not</em> safely precompilable, it should call <code>__precompile__(false)</code> in order to throw an error if Julia attempts to precompile it.</p><p><code>__precompile__()</code> should <em>not</em> be used in a module unless all of its dependencies are also using <code>__precompile__()</code>. Failure to do so can result in a runtime error when loading the module.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L256-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.include" href="#Base.include"><code>Base.include</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">include(m::Module, path::AbstractString)</code></pre><p>Evaluate the contents of the input source file into module <code>m</code>. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to <code>include</code> will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L537-L545">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.include_string" href="#Base.include_string"><code>Base.include_string</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">include_string(m::Module, code::AbstractString, filename::AbstractString=&quot;string&quot;)</code></pre><p>Like <code>include</code>, except reads code from the given string rather than from a file.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L488-L492">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.include_dependency" href="#Base.include_dependency"><code>Base.include_dependency</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">include_dependency(path::AbstractString)</code></pre><p>In a module, declare that the file specified by <code>path</code> (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</p><p>This is only needed if your module depends on a file that is not used via <code>include</code>. It has no effect outside of compilation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L222-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Docs.apropos" href="#Base.Docs.apropos"><code>Base.Docs.apropos</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">apropos(string)</code></pre><p>Search through all documentation for a string, ignoring case.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/utils.jl#L442-L446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.which-Tuple{Any,Any}" href="#Base.which-Tuple{Any,Any}"><code>Base.which</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">which(f, types)</code></pre><p>Returns the method of <code>f</code> (a <code>Method</code> object) that would be called for arguments of the given <code>types</code>.</p><p>If <code>types</code> is an abstract type, then the method that would be called by <code>invoke</code> is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L899-L905">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.which-Tuple{Symbol}" href="#Base.which-Tuple{Symbol}"><code>Base.which</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">which(symbol)</code></pre><p>Return the module in which the binding for the variable referenced by <code>symbol</code> in module <code>Main</code> was created.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L919-L923">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@which" href="#Base.@which"><code>Base.@which</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@which</code></pre><p>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the <code>Method</code> object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the <code>which</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L480-L487">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.methods" href="#Base.methods"><code>Base.methods</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">methods(f, [types])</code></pre><p>Returns the method table for <code>f</code>.</p><p>If <code>types</code> is specified, returns an array of methods whose types match.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L666-L672">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.methodswith" href="#Base.methodswith"><code>Base.methodswith</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">methodswith(typ[, module or function][, showparents::Bool=false])</code></pre><p>Return an array of methods with an argument of type <code>typ</code>.</p><p>The optional second argument restricts the search to a particular module or function (the default is all top-level modules).</p><p>If optional <code>showparents</code> is <code>true</code>, also return arguments with a parent type of <code>typ</code>, excluding type <code>Any</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L563-L573">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@show" href="#Base.@show"><code>Base.@show</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@show</code></pre><p>Show an expression and result, returning the result.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/show.jl#L331-L335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.versioninfo" href="#Base.versioninfo"><code>Base.versioninfo</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">versioninfo(io::IO=STDOUT; verbose::Bool=false, packages::Bool=false)</code></pre><p>Print information about the version of Julia in use. The output is controlled with boolean keyword arguments:</p><ul><li><p><code>packages</code>: print information about installed packages</p></li><li><p><code>verbose</code>: print all additional information</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L250-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.workspace" href="#Base.workspace"><code>Base.workspace</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">workspace()</code></pre><p>Replace the top-level module (<code>Main</code>) with a new one, providing a clean workspace. The previous <code>Main</code> module is made available as <code>LastMain</code>.</p><p>If <code>Package</code> was previously loaded, <code>using Package</code> in the new <code>Main</code> will re-use the loaded copy. Run <code>reload(&quot;Package&quot;)</code> first to load a fresh copy.</p><p>This function should only be used interactively.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L672-L682">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ans" href="#ans"><code>ans</code></a> â <span class="docstring-category">Keyword</span>.</div><div><pre><code class="language-none">ans</code></pre><p>A variable referring to the last computed value, automatically set at the interactive prompt.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L678-L682">source</a></section><h2><a class="nav-anchor" id="All-Objects-1" href="#All-Objects-1">All Objects</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.:===" href="#Core.:==="><code>Core.:===</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">===(x,y) -&gt; Bool
â¡(x,y) -&gt; Bool</code></pre><p>Determine whether <code>x</code> and <code>y</code> are identical, in the sense that no program could distinguish them. Compares mutable objects by address in memory, and compares immutable objects (such as numbers) by contents at the bit level. This function is sometimes called <code>egal</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a == b
true

julia&gt; a === b
false

julia&gt; a === a
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L161-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.isa" href="#Core.isa"><code>Core.isa</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isa(x, type) -&gt; Bool</code></pre><p>Determine whether <code>x</code> is of the given <code>type</code>. Can also be used as an infix operator, e.g. <code>x isa type</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L971-L976">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isequal" href="#Base.isequal"><code>Base.isequal</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isequal(x, y)</code></pre><p>Similar to <code>==</code>, except treats all floating-point <code>NaN</code> values as equal to each other, and treats <code>-0.0</code> as unequal to <code>0.0</code>. The default implementation of <code>isequal</code> calls <code>==</code>, so if you have a type that doesn&#39;t have these floating-point subtleties then you probably only need to define <code>==</code>.</p><p><code>isequal</code> is the comparison function used by hash tables (<code>Dict</code>). <code>isequal(x,y)</code> must imply that <code>hash(x) == hash(y)</code>.</p><p>This typically means that if you define your own <code>==</code> function then you must define a corresponding <code>hash</code> (and vice versa). Collections typically implement <code>isequal</code> by calling <code>isequal</code> recursively on all contents.</p><p>Scalar types generally do not need to implement <code>isequal</code> separate from <code>==</code>, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on <code>isnan</code>, <code>signbit</code>, and <code>==</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isequal([1., NaN], [1., NaN])
true

julia&gt; [1., NaN] == [1., NaN]
false

julia&gt; 0.0 == -0.0
true

julia&gt; isequal(0.0, -0.0)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L70-L103">source</a><div><pre><code class="language-none">isequal(x::Nullable, y::Nullable)</code></pre><p>If neither <code>x</code> nor <code>y</code> is null, compare them according to their values (i.e. <code>isequal(get(x), get(y))</code>). Else, return <code>true</code> if both arguments are null, and <code>false</code> if one is null but not the other: nulls are considered equal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isequal(Nullable(5), Nullable(5))
true

julia&gt; isequal(Nullable(5), Nullable(4))
false

julia&gt; isequal(Nullable(5), Nullable())
false

julia&gt; isequal(Nullable(), Nullable())
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/nullable.jl#L224-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless" href="#Base.isless"><code>Base.isless</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isless(x, y)</code></pre><p>Test whether <code>x</code> is less than <code>y</code>, according to a canonical total order. Values that are normally unordered, such as <code>NaN</code>, are ordered in an arbitrary but consistent fashion. This is the default comparison used by <a href="sort.html#Base.sort"><code>sort</code></a>. Non-numeric types with a canonical total order should implement this function. Numeric types only need to implement it if they have special values such as <code>NaN</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L113-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless-Tuple{Nullable,Nullable}" href="#Base.isless-Tuple{Nullable,Nullable}"><code>Base.isless</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(x::Nullable, y::Nullable)</code></pre><p>If neither <code>x</code> nor <code>y</code> is null, compare them according to their values (i.e. <code>isless(get(x), get(y))</code>). Else, return <code>true</code> if only <code>y</code> is null, and <code>false</code> otherwise: nulls are always considered greater than non-nulls, but not greater than another null.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isless(Nullable(6), Nullable(5))
false

julia&gt; isless(Nullable(5), Nullable(6))
true

julia&gt; isless(Nullable(5), Nullable(4))
false

julia&gt; isless(Nullable(5), Nullable())
true

julia&gt; isless(Nullable(), Nullable())
false

julia&gt; isless(Nullable(), Nullable(5))
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/nullable.jl#L258-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ifelse" href="#Base.ifelse"><code>Base.ifelse</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ifelse(condition::Bool, x, y)</code></pre><p>Return <code>x</code> if <code>condition</code> is <code>true</code>, otherwise return <code>y</code>. This differs from <code>?</code> or <code>if</code> in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using <code>ifelse</code> instead of an <code>if</code> statement can eliminate the branch in generated code and provide higher performance in tight loops.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ifelse(1 &gt; 2, 1, 2)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L304-L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lexcmp" href="#Base.lexcmp"><code>Base.lexcmp</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lexcmp(x, y)</code></pre><p>Compare <code>x</code> and <code>y</code> lexicographically and return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. This function should be defined for lexicographically comparable types, and <code>lexless</code> will call <code>lexcmp</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lexcmp(&quot;abc&quot;, &quot;abd&quot;)
-1

julia&gt; lexcmp(&quot;abc&quot;, &quot;abc&quot;)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L342-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lexless" href="#Base.lexless"><code>Base.lexless</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lexless(x, y)</code></pre><p>Determine whether <code>x</code> is lexicographically less than <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lexless(&quot;abc&quot;, &quot;abd&quot;)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L360-L370">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.typeof" href="#Core.typeof"><code>Core.typeof</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">typeof(x)</code></pre><p>Get the concrete type of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1120-L1124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.tuple" href="#Core.tuple"><code>Core.tuple</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tuple(xs...)</code></pre><p>Construct a tuple of the given objects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tuple(1, &#39;a&#39;, pi)
(1, &#39;a&#39;, Ï = 3.1415926535897...)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1082-L1092">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ntuple" href="#Base.ntuple"><code>Base.ntuple</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ntuple(f::Function, n::Integer)</code></pre><p>Create a tuple of length <code>n</code>, computing each element as <code>f(i)</code>, where <code>i</code> is the index of the element.</p><pre><code class="language-julia-repl">julia&gt; ntuple(i -&gt; 2*i, 4)
(2, 4, 6, 8)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/tuple.jl#L110-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.object_id" href="#Base.object_id"><code>Base.object_id</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">object_id(x)</code></pre><p>Get a hash value for <code>x</code> based on object identity. <code>object_id(x)==object_id(y)</code> if <code>x === y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L224-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hash" href="#Base.hash"><code>Base.hash</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hash(x[, h::UInt])</code></pre><p>Compute an integer hash code such that <code>isequal(x,y)</code> implies <code>hash(x)==hash(y)</code>. The optional second argument <code>h</code> is a hash code to be mixed with the result.</p><p>New types should implement the 2-argument form, typically by calling the 2-argument <code>hash</code> method recursively in order to mix hashes of the contents with each other (and with <code>h</code>). Typically, any type that implements <code>hash</code> should also implement its own <code>==</code> (hence <code>isequal</code>) to guarantee the property mentioned above.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/hashing.jl#L5-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.finalizer" href="#Base.finalizer"><code>Base.finalizer</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">finalizer(x, f)</code></pre><p>Register a function <code>f(x)</code> to be called when there are no program-accessible references to <code>x</code>. The type of <code>x</code> must be a <code>mutable struct</code>, otherwise the behavior of this function is unpredictable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/gcutils.jl#L7-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.finalize" href="#Base.finalize"><code>Base.finalize</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">finalize(x)</code></pre><p>Immediately run finalizers registered for object <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/gcutils.jl#L31-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">copy(x)</code></pre><p>Create a shallow copy of <code>x</code>: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/array.jl#L208-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.deepcopy" href="#Base.deepcopy"><code>Base.deepcopy</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">deepcopy(x)</code></pre><p>Create a deep copy of <code>x</code>: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling <code>deepcopy</code> on an object should generally have the same effect as serializing and then deserializing it.</p><p>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</p><p>While it isn&#39;t normally necessary, user-defined types can override the default <code>deepcopy</code> behavior by defining a specialized version of the function <code>deepcopy_internal(x::T, dict::ObjectIdDict)</code> (which shouldn&#39;t otherwise be used), where <code>T</code> is the type to be specialized for, and <code>dict</code> keeps track of objects copied so far within the recursion. Within the definition, <code>deepcopy_internal</code> should be used in place of <code>deepcopy</code>, and the <code>dict</code> variable should be updated as appropriate before returning.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/deepcopy.jl#L8-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.isdefined" href="#Core.isdefined"><code>Core.isdefined</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isdefined(m::Module, s::Symbol)
isdefined(object, s::Symbol)
isdefined(object, index::Int)</code></pre><p>Tests whether an assignable location is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1127-L1134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@isdefined" href="#Base.@isdefined"><code>Base.@isdefined</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@isdefined s -&gt; Bool</code></pre><p>Tests whether variable <code>s</code> is defined in the current scope.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; function f()
           println(@isdefined x)
           x = 3
           println(@isdefined x)
       end
f (generic function with 1 method)

julia&gt; f()
false
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L201-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">convert(T, x)</code></pre><p>Convert <code>x</code> to a value of type <code>T</code>.</p><p>If <code>T</code> is an <a href="numbers.html#Core.Integer"><code>Integer</code></a> type, an <a href="base.html#Core.InexactError"><code>InexactError</code></a> will be raised if <code>x</code> is not representable by <code>T</code>, for example if <code>x</code> is not integer-valued, or is outside the range supported by <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Int, 3.0)
3

julia&gt; convert(Int, 3.5)
ERROR: InexactError: convert(Int64, 3.5)
Stacktrace:
 [1] convert(::Type{Int64}, ::Float64) at ./float.jl:701</code></pre><p>If <code>T</code> is a <a href="numbers.html#Core.AbstractFloat"><code>AbstractFloat</code></a> or <a href="numbers.html#Base.Rational"><code>Rational</code></a> type, then it will return the closest value to <code>x</code> representable by <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; x = 1/3
0.3333333333333333

julia&gt; convert(Float32, x)
0.33333334f0

julia&gt; convert(Rational{Int32}, x)
1//3

julia&gt; convert(Rational{Int64}, x)
6004799503160661//18014398509481984</code></pre><p>If <code>T</code> is a collection type and <code>x</code> a collection, the result of <code>convert(T, x)</code> may alias <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; x = Int[1,2,3];

julia&gt; y = convert(Vector{Int}, x);

julia&gt; y === x
true</code></pre><p>Similarly, if <code>T</code> is a composite type and <code>x</code> a related instance, the result of <code>convert(T, x)</code> may alias part or all of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; x = speye(5);

julia&gt; typeof(x)
SparseMatrixCSC{Float64,Int64}

julia&gt; y = convert(SparseMatrixCSC{Float64,Int64}, x);

julia&gt; z = convert(SparseMatrixCSC{Float32,Int64}, y);

julia&gt; y === x
true

julia&gt; z === x
false

julia&gt; z.colptr === x.colptr
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L64-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote" href="#Base.promote"><code>Base.promote</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">promote(xs...)</code></pre><p>Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; promote(Int8(1), Float16(4.5), Float32(4.1))
(1.0f0, 4.5f0, 4.1f0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/promotion.jl#L187-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.oftype" href="#Base.oftype"><code>Base.oftype</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">oftype(x, y)</code></pre><p>Convert <code>y</code> to the type of <code>x</code> (<code>convert(typeof(x), y)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L275-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.widen" href="#Base.widen"><code>Base.widen</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">widen(x)</code></pre><p>If <code>x</code> is a type, return a &quot;larger&quot; type (for numeric types, this will be a type with at least as much range and precision as the argument, and usually more). Otherwise <code>x</code> is converted to <code>widen(typeof(x))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; widen(Int32)
Int64

julia&gt; widen(1.5f0)
1.5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L900-L915">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.identity" href="#Base.identity"><code>Base.identity</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">identity(x)</code></pre><p>The identity function. Returns its argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; identity(&quot;Well, what did you expect?&quot;)
&quot;Well, what did you expect?&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L429-L439">source</a></section><h2><a class="nav-anchor" id="Dealing-with-Types-1" href="#Dealing-with-Types-1">Dealing with Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.supertype" href="#Base.supertype"><code>Base.supertype</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">supertype(T::DataType)</code></pre><p>Return the supertype of DataType <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; supertype(Int32)
Signed</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L31-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.:&lt;:" href="#Core.:&lt;:"><code>Core.:&lt;:</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&lt;:(T1, T2)</code></pre><p>Subtype operator: returns <code>true</code> if and only if all values of type <code>T1</code> are also of type <code>T2</code>.</p><pre><code class="language-julia-repl">julia&gt; Float64 &lt;: AbstractFloat
true

julia&gt; Vector{Int} &lt;: AbstractArray
true

julia&gt; Matrix{Float64} &lt;: Matrix{AbstractFloat}
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L5-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;:" href="#Base.:&gt;:"><code>Base.:&gt;:</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&gt;:(T1, T2)</code></pre><p>Supertype operator, equivalent to <code>T2 &lt;: T1</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L24-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.subtypes" href="#Base.subtypes"><code>Base.subtypes</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">subtypes(T::DataType)</code></pre><p>Return a list of immediate subtypes of DataType <code>T</code>. Note that all currently loaded subtypes are included, including those not visible in the current module.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; subtypes(Integer)
4-element Array{Union{DataType, UnionAll},1}:
 BigInt
 Bool
 Signed
 Unsigned</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L553-L568">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.typemin" href="#Base.typemin"><code>Base.typemin</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">typemin(T)</code></pre><p>The lowest value representable by the given (real) numeric DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; typemin(Float16)
-Inf16

julia&gt; typemin(Float32)
-Inf32</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L626-L639">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.typemax" href="#Base.typemax"><code>Base.typemax</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">typemax(T)</code></pre><p>The highest value representable by the given (real) numeric <code>DataType</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L642-L646">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.realmin" href="#Base.realmin"><code>Base.realmin</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">realmin(T)</code></pre><p>The smallest in absolute value non-subnormal value representable by the given floating-point DataType <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/float.jl#L745-L750">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.realmax" href="#Base.realmax"><code>Base.realmax</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">realmax(T)</code></pre><p>The highest finite value representable by the given floating-point DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; realmax(Float16)
Float16(6.55e4)

julia&gt; realmax(Float32)
3.4028235f38</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/float.jl#L753-L766">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.maxintfloat" href="#Base.maxintfloat"><code>Base.maxintfloat</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">maxintfloat(T)</code></pre><p>The largest integer losslessly representable by the given floating-point DataType <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/floatfuncs.jl#L19-L23">source</a><div><pre><code class="language-none">maxintfloat(T, S)</code></pre><p>The largest integer losslessly representable by the given floating-point DataType <code>T</code> that also does not exceed the maximum integer representable by the integer DataType <code>S</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/floatfuncs.jl#L29-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sizeof-Tuple{Type}" href="#Base.sizeof-Tuple{Type}"><code>Base.sizeof</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sizeof(T)</code></pre><p>Size, in bytes, of the canonical binary representation of the given DataType <code>T</code>, if any.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sizeof(Float32)
4

julia&gt; sizeof(Complex128)
16</code></pre><p>If <code>T</code> does not have a specific size, an error is thrown.</p><pre><code class="language-julia-repl">julia&gt; sizeof(Base.LinAlg.LU)
ERROR: argument is an abstract type; size is indeterminate
Stacktrace:
 [1] sizeof(::Type{T} where T) at ./essentials.jl:367</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L344-L366">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eps-Tuple{Type{#s60} where #s60&lt;:AbstractFloat}" href="#Base.eps-Tuple{Type{#s60} where #s60&lt;:AbstractFloat}"><code>Base.eps</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eps(::Type{T}) where T&lt;:AbstractFloat
eps()</code></pre><p>Returns the <em>machine epsilon</em> of the floating point type <code>T</code> (<code>T = Float64</code> by default). This is defined as the gap between 1 and the next largest value representable by <code>T</code>, and is equivalent to <code>eps(one(T))</code>.</p><pre><code class="language-julia-repl">julia&gt; eps()
2.220446049250313e-16

julia&gt; eps(Float32)
1.1920929f-7

julia&gt; 1.0 + eps()
1.0000000000000002

julia&gt; 1.0 + eps()/2
1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/float.jl#L772-L793">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eps-Tuple{AbstractFloat}" href="#Base.eps-Tuple{AbstractFloat}"><code>Base.eps</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eps(x::AbstractFloat)</code></pre><p>Returns the <em>unit in last place</em> (ulp) of <code>x</code>. This is the distance between consecutive representable floating point values at <code>x</code>. In most cases, if the distance on either side of <code>x</code> is different, then the larger of the two is taken, that is</p><pre><code class="language-none">eps(x) == max(x-prevfloat(x), nextfloat(x)-x)</code></pre><p>The exceptions to this rule are the smallest and largest finite values (e.g. <code>nextfloat(-Inf)</code> and <code>prevfloat(Inf)</code> for <a href="numbers.html#Core.Float64"><code>Float64</code></a>), which round to the smaller of the values.</p><p>The rationale for this behavior is that <code>eps</code> bounds the floating point rounding error. Under the default <code>RoundNearest</code> rounding mode, if <span>$y$</span> is a real number and <span>$x$</span> is the nearest floating point number to <span>$y$</span>, then</p><div>\[|y-x| \leq \operatorname{eps}(x)/2.\]</div><pre><code class="language-julia-repl">julia&gt; eps(1.0)
2.220446049250313e-16

julia&gt; eps(prevfloat(2.0))
2.220446049250313e-16

julia&gt; eps(2.0)
4.440892098500626e-16

julia&gt; x = prevfloat(Inf)      # largest finite Float64
1.7976931348623157e308

julia&gt; x + eps(x)/2            # rounds up
Inf

julia&gt; x + prevfloat(eps(x)/2) # rounds down
1.7976931348623157e308</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/float.jl#L796-L836">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote_type" href="#Base.promote_type"><code>Base.promote_type</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">promote_type(type1, type2)</code></pre><p>Determine a type big enough to hold values of each argument type without loss, whenever possible. In some cases, where no type exists to which both types can be promoted losslessly, some loss is tolerated; for example, <code>promote_type(Int64, Float64)</code> returns <a href="numbers.html#Core.Float64"><code>Float64</code></a> even though strictly, not all <a href="numbers.html#Core.Int64"><code>Int64</code></a> values can be represented exactly as <code>Float64</code> values.</p><pre><code class="language-julia-repl">julia&gt; promote_type(Int64, Float64)
Float64

julia&gt; promote_type(Int32, Int64)
Int64

julia&gt; promote_type(Float32, BigInt)
BigFloat</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/promotion.jl#L130-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote_rule" href="#Base.promote_rule"><code>Base.promote_rule</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">promote_rule(type1, type2)</code></pre><p>Specifies what type should be used by <a href="base.html#Base.promote"><code>promote</code></a> when given values of types <code>type1</code> and <code>type2</code>. This function should not be called directly, but should have definitions added to it for new types as appropriate.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/promotion.jl#L171-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.getfield" href="#Core.getfield"><code>Core.getfield</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getfield(value, name::Symbol)</code></pre><p>Extract a named field from a <code>value</code> of composite type. The syntax <code>a.b</code> calls <code>getfield(a, :b)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1//2
1//2

julia&gt; getfield(a, :num)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1095-L1109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.setfield!" href="#Core.setfield!"><code>Core.setfield!</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setfield!(value, name::Symbol, x)</code></pre><p>Assign <code>x</code> to a named field in <code>value</code> of composite type. The syntax <code>a.b = c</code> calls <code>setfield!(a, :b, c)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1112-L1117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fieldoffset" href="#Base.fieldoffset"><code>Base.fieldoffset</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fieldoffset(type, i)</code></pre><p>The byte offset of field <code>i</code> of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</p><pre><code class="language-julia-repl">julia&gt; structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];

julia&gt; structinfo(Base.Filesystem.StatStruct)
12-element Array{Tuple{UInt64,Symbol,DataType},1}:
 (0x0000000000000000, :device, UInt64)
 (0x0000000000000008, :inode, UInt64)
 (0x0000000000000010, :mode, UInt64)
 (0x0000000000000018, :nlink, Int64)
 (0x0000000000000020, :uid, UInt64)
 (0x0000000000000028, :gid, UInt64)
 (0x0000000000000030, :rdev, UInt64)
 (0x0000000000000038, :size, Int64)
 (0x0000000000000040, :blksize, Int64)
 (0x0000000000000048, :blocks, Int64)
 (0x0000000000000050, :mtime, Float64)
 (0x0000000000000058, :ctime, Float64)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L383-L407">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.fieldtype" href="#Core.fieldtype"><code>Core.fieldtype</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fieldtype(T, name::Symbol | index::Int)</code></pre><p>Determine the declared type of a field (specified by name or index) in a composite DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct Foo
           x::Int64
           y::String
       end

julia&gt; fieldtype(Foo, :x)
Int64

julia&gt; fieldtype(Foo, 2)
String</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L410-L428">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isimmutable" href="#Base.isimmutable"><code>Base.isimmutable</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isimmutable(v)</code></pre><p>Return <code>true</code> iff value <code>v</code> is immutable.  See <a href="../manual/types.html#Mutable-Composite-Types-1">Mutable Composite Types</a> for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of <code>DataType</code> is mutable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isimmutable(1)
true

julia&gt; isimmutable([1,2])
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L254-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isbits" href="#Base.isbits"><code>Base.isbits</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isbits(T)</code></pre><p>Return <code>true</code> if <code>T</code> is a &quot;plain data&quot; type, meaning it is immutable and contains no references to other values. Typical examples are numeric types such as <a href="numbers.html#Core.UInt8"><code>UInt8</code></a>, <a href="numbers.html#Core.Float64"><code>Float64</code></a>, and <a href="numbers.html#Base.Complex"><code>Complex{Float64}</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isbits(Complex{Float64})
true

julia&gt; isbits(Complex)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L274-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isconcrete" href="#Base.isconcrete"><code>Base.isconcrete</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isconcrete(T)</code></pre><p>Determine whether <code>T</code> is a concrete type, meaning it can have direct instances (values <code>x</code> such that <code>typeof(x) === T</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isconcrete(Complex)
false

julia&gt; isconcrete(Complex{Float32})
true

julia&gt; isconcrete(Vector{Complex})
true

julia&gt; isconcrete(Vector{Complex{Float32}})
true

julia&gt; isconcrete(Union{})
false

julia&gt; isconcrete(Union{Int,String})
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L296-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.typejoin" href="#Base.typejoin"><code>Base.typejoin</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">typejoin(T, S)</code></pre><p>Compute a type that contains both <code>T</code> and <code>S</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/promotion.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.typeintersect" href="#Base.typeintersect"><code>Base.typeintersect</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">typeintersect(T, S)</code></pre><p>Compute a type that contains the intersection of <code>T</code> and <code>S</code>. Usually this will be the smallest such type or one close to it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L374-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.instances" href="#Base.instances"><code>Base.instances</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">instances(T::Type)</code></pre><p>Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see <code>@enum</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @enum Colors Red Blue Green

julia&gt; instances(Colors)
(Red::Colors = 0, Blue::Colors = 1, Green::Colors = 2)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L486-L499">source</a></section><h2><a class="nav-anchor" id="Special-Types-1" href="#Special-Types-1">Special Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Void" href="#Core.Void"><code>Core.Void</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Void</code></pre><p>A type with no fields that is the type <a href="constants.html#Core.nothing"><code>nothing</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L699-L703">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Any" href="#Core.Any"><code>Core.Any</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Any::DataType</code></pre><p><code>Any</code> is the union of all types. It has the defining property <code>isa(x, Any) == true</code> for any <code>x</code>. <code>Any</code> therefore describes the entire universe of possible values. For example <code>Integer</code> is a subset of <code>Any</code> that includes <code>Int</code>, <code>Int8</code>, and other integer types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1271-L1277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Enums.@enum" href="#Base.Enums.@enum"><code>Base.Enums.@enum</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@enum EnumName[::BaseType] EnumValue1[=x] EnumValue2[=y]</code></pre><p>Create an <code>Enum{BaseType}</code> subtype with name <code>EnumName</code> and enum member values of <code>EnumValue1</code> and <code>EnumValue2</code> with optional assigned values of <code>x</code> and <code>y</code>, respectively. <code>EnumName</code> can be used just like other types and enum member values as regular values, such as</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @enum Fruit apple=1 orange=2 kiwi=3

julia&gt; f(x::Fruit) = &quot;I&#39;m a Fruit with value: $(Int(x))&quot;
f (generic function with 1 method)

julia&gt; f(apple)
&quot;I&#39;m a Fruit with value: 1&quot;</code></pre><p><code>BaseType</code>, which defaults to <a href="numbers.html#Core.Int32"><code>Int32</code></a>, must be a primitive subtype of <code>Integer</code>. Member values can be converted between the enum type and <code>BaseType</code>. <code>read</code> and <code>write</code> perform these conversions automatically.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/Enums.jl#L31-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Union" href="#Core.Union"><code>Core.Union</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="base.html#Union{}"><code>Union{}</code></a> is the bottom type of Julia.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; IntOrString = Union{Int,AbstractString}
Union{AbstractString, Int64}

julia&gt; 1 :: IntOrString
1

julia&gt; &quot;Hello!&quot; :: IntOrString
&quot;Hello!&quot;

julia&gt; 1.0 :: IntOrString
ERROR: TypeError: typeassert: expected Union{AbstractString, Int64}, got Float64</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1295-L1315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Union{}" href="#Union{}"><code>Union{}</code></a> â <span class="docstring-category">Keyword</span>.</div><div><pre><code class="language-none">Union{}</code></pre><p><code>Union{}</code>, the empty <a href="base.html#Core.Union"><code>Union</code></a> of types, is the type that has no values. That is, it has the defining property <code>isa(x, Union{}) == false</code> for any <code>x</code>. <code>Base.Bottom</code> is defined as its alias and the type of <code>Union{}</code> is <code>Core.TypeofBottom</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa(nothing, Union{})
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1280-L1292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.UnionAll" href="#Core.UnionAll"><code>Core.UnionAll</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">UnionAll</code></pre><p>A union of types over all values of a type parameter. <code>UnionAll</code> is used to describe parametric types where the values of some parameters are not known.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; typeof(Vector)
UnionAll

julia&gt; typeof(Vector{Int})
DataType</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1319-L1333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Tuple" href="#Core.Tuple"><code>Core.Tuple</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Tuple{Types...}</code></pre><p>Tuples are an abstraction of the arguments of a function â without the function itself. The salient aspects of a function&#39;s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.</p><p>Tuple types are covariant in their parameters: <code>Tuple{Int}</code> is a subtype of <code>Tuple{Any}</code>. Therefore <code>Tuple{Any}</code> is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.</p><p>See the manual section on <a href="../manual/types.html#Tuple-Types-1">Tuple Types</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1383-L1395">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Val" href="#Base.Val"><code>Base.Val</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Val(c)</code></pre><p>Return <code>Val{c}()</code>, which contains no run-time data. Types like this can be used to pass the information between functions through the value <code>c</code>, which must be an <code>isbits</code> value. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f(::Val{true}) = &quot;Good&quot;
f (generic function with 1 method)

julia&gt; f(::Val{false}) = &quot;Bad&quot;
f (generic function with 2 methods)

julia&gt; f(Val(true))
&quot;Good&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L593-L612">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Vararg" href="#Core.Vararg"><code>Core.Vararg</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vararg{T,N}</code></pre><p>The last parameter of a tuple type <a href="base.html#Core.Tuple"><code>Tuple</code></a> can be the special type <code>Vararg</code>, which denotes any number of trailing elements. The type <code>Vararg{T,N}</code> corresponds to exactly <code>N</code> elements of type <code>T</code>. <code>Vararg{T}</code> corresponds to zero or more elements of type <code>T</code>. <code>Vararg</code> tuple types are used to represent the arguments accepted by varargs methods (see the section on <a href="../manual/functions.html#Varargs-Functions-1">Varargs Functions</a> in the manual.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia&gt; isa((&quot;1&quot;,), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2,3.0), mytupletype)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1355-L1380">source</a></section><h2><a class="nav-anchor" id="Generic-Functions-1" href="#Generic-Functions-1">Generic Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Function" href="#Core.Function"><code>Core.Function</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Function</code></pre><p>Abstract type of all functions.</p><pre><code class="language-julia-repl">julia&gt; isa(+, Function)
true

julia&gt; typeof(sin)
Base.#sin

julia&gt; ans &lt;: Function
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L721-L736">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.method_exists" href="#Base.method_exists"><code>Base.method_exists</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">method_exists(f, Tuple type, world=typemax(UInt)) -&gt; Bool</code></pre><p>Determine whether the given generic function has a method matching the given <code>Tuple</code> of argument types with the upper bound of world age given by <code>world</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; method_exists(length, Tuple{Array})
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L999-L1010">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.applicable" href="#Core.applicable"><code>Core.applicable</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">applicable(f, args...) -&gt; Bool</code></pre><p>Determine whether the given generic function has a method applicable to the given arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; function f(x, y)
           x + y
       end;

julia&gt; applicable(f, 1)
false

julia&gt; applicable(f, 1, 2)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L929-L946">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.invoke" href="#Core.invoke"><code>Core.invoke</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">invoke(f, argtypes::Type, args...; kwargs...)</code></pre><p>Invoke a method for the given generic function <code>f</code> matching the specified types <code>argtypes</code> on the specified arguments <code>args</code> and passing the keyword arguments <code>kwargs</code>. The arguments <code>args</code> must conform with the specified types in <code>argtypes</code>, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f(x::Real) = x^2;

julia&gt; f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);

julia&gt; f(2)
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L949-L968">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.invokelatest" href="#Base.invokelatest"><code>Base.invokelatest</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">invokelatest(f, args...; kwargs...)</code></pre><p>Calls <code>f(args...; kwargs...)</code>, but guarantees that the most recent method of <code>f</code> will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function <code>f</code>. (The drawback is that <code>invokelatest</code> is somewhat slower than calling <code>f</code> directly, and the type of the result cannot be inferred by the compiler.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L648-L657">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:|&gt;" href="#Base.:|&gt;"><code>Base.:|&gt;</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">|&gt;(x, f)</code></pre><p>Applies a function to the preceding argument. This allows for easy function chaining.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [1:5;] |&gt; x-&gt;x.^2 |&gt; sum |&gt; inv
0.01818181818181818</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L920-L930">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:â" href="#Base.:â"><code>Base.:â</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">f â g</code></pre><p>Compose functions: i.e. <code>(f â g)(args...)</code> means <code>f(g(args...))</code>. The <code>â</code> symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing <code>\circ&lt;tab&gt;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; map(uppercaseâhex, 250:255)
6-element Array{String,1}:
 &quot;FA&quot;
 &quot;FB&quot;
 &quot;FC&quot;
 &quot;FD&quot;
 &quot;FE&quot;
 &quot;FF&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L935-L952">source</a></section><h2><a class="nav-anchor" id="Syntax-1" href="#Syntax-1">Syntax</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.eval" href="#Core.eval"><code>Core.eval</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval([m::Module], expr::Expr)</code></pre><p>Evaluate an expression in the given module and return the result. Every <code>Module</code> (except those defined with <code>baremodule</code>) has its own 1-argument definition of <code>eval</code>, which evaluates expressions in that module.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L144-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@eval" href="#Base.@eval"><code>Base.@eval</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@eval [mod,] ex</code></pre><p>Evaluate an expression with values interpolated into it using <code>eval</code>. If two arguments are provided, the first is the module to evaluate in.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L138-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.evalfile" href="#Base.evalfile"><code>Base.evalfile</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">evalfile(path::AbstractString, args::Vector{String}=String[])</code></pre><p>Load the file using <a href="base.html#Base.include"><code>include</code></a>, evaluate all expressions, and return the value of the last one.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/loading.jl#L548-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.esc" href="#Base.esc"><code>Base.esc</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">esc(e)</code></pre><p>Only valid in the context of an <code>Expr</code> returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the <a href="../manual/metaprogramming.html#man-macros-1">Macros</a> section of the Metaprogramming chapter of the manual for more details and examples.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L406-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@inbounds" href="#Base.@inbounds"><code>Base.@inbounds</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@inbounds(blk)</code></pre><p>Eliminates array bounds checking within expressions.</p><p>In the example below the in-range check for referencing element <code>i</code> of array <code>A</code> is skipped to improve performance.</p><pre><code class="language-julia">function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Using <code>@inbounds</code> may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use <code>@inbounds</code> when it is certain from the information locally available that all accesses are in bounds.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L459-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@boundscheck" href="#Base.@boundscheck"><code>Base.@boundscheck</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@boundscheck(blk)</code></pre><p>Annotates the expression <code>blk</code> as a bounds checking block, allowing it to be elided by <a href="base.html#Base.@inbounds"><code>@inbounds</code></a>.</p><p>Note that the function in which <code>@boundscheck</code> is written must be inlined into its caller with <a href="base.html#Base.@inline"><code>@inline</code></a> in order for <code>@inbounds</code> to have effect.</p><pre><code class="language-julia-repl">julia&gt; @inline function g(A, i)
           @boundscheck checkbounds(A, i)
           return &quot;accessing ($A)[$i]&quot;
       end
       f1() = return g(1:2, -1)
       f2() = @inbounds return g(1:2, -1)
f2 (generic function with 1 method)

julia&gt; f1()
ERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]
Stacktrace:
 [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:428
 [2] checkbounds at ./abstractarray.jl:392 [inlined]
 [3] g at ./REPL[20]:2 [inlined]
 [4] f1() at ./REPL[20]:5

julia&gt; f2()
&quot;accessing (1:2)[-1]&quot;</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The <code>@boundscheck</code> annotation allows you, as a library writer, to opt-in to allowing <em>other code</em> to remove your bounds checks with <a href="base.html#Base.@inbounds"><code>@inbounds</code></a>. As noted there, the caller must verifyâusing information they can accessâthat their accesses are valid before using <code>@inbounds</code>. For indexing into your <a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a> subclasses, for example, this involves checking the indices against its <a href="arrays.html#Base.size"><code>size</code></a>. Therefore, <code>@boundscheck</code> annotations should only be added to a <a href="collections.html#Base.getindex"><code>getindex</code></a> or <a href="collections.html#Base.setindex!"><code>setindex!</code></a> implementation after you are certain its behavior is correct.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L415-L454">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@inline" href="#Base.@inline"><code>Base.@inline</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@inline</code></pre><p>Give a hint to the compiler that this function is worth inlining.</p><p>Small functions typically do not need the <code>@inline</code> annotation, as the compiler does it automatically. By using <code>@inline</code> on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:</p><pre><code class="language-julia">@inline function bigfunction(x)
    #=
        Function Definition
    =#
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L153-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@noinline" href="#Base.@noinline"><code>Base.@noinline</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@noinline</code></pre><p>Prevents the compiler from inlining a function.</p><p>Small functions are typically inlined automatically. By using <code>@noinline</code> on small functions, auto-inlining can be prevented. This is shown in the following example:</p><pre><code class="language-julia">@noinline function smallfunction(x)
    #=
        Function Definition
    =#
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L175-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@nospecialize" href="#Base.@nospecialize"><code>Base.@nospecialize</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nospecialize</code></pre><p>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</p><pre><code class="language-julia">function example_function(@nospecialize x)
    ...
end

function example_function(@nospecialize(x = 1), y)
    ...
end

function example_function(x, y, z)
    @nospecialize x y
    ...
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L21-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.gensym" href="#Base.gensym"><code>Base.gensym</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gensym([tag])</code></pre><p>Generates a symbol which will not conflict with other variable names.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@gensym" href="#Base.@gensym"><code>Base.@gensym</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@gensym</code></pre><p>Generates a gensym symbol for a variable. For example, <code>@gensym x y</code> is transformed into <code>x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L18-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@goto" href="#Base.@goto"><code>Base.@goto</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@goto name</code></pre><p><code>@goto name</code> unconditionally jumps to the statement at the location <a href="base.html#Base.@label"><code>@label name</code></a>.</p><p><code>@label</code> and <code>@goto</code> cannot create jumps to different top-level statements. Attempts cause an error. To still use <code>@goto</code>, enclose the <code>@label</code> and <code>@goto</code> in a block.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L501-L508">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@label" href="#Base.@label"><code>Base.@label</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@label name</code></pre><p>Labels a statement with the symbolic label <code>name</code>. The label marks the end-point of an unconditional jump with <a href="base.html#Base.@goto"><code>@goto name</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L491-L496">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@polly" href="#Base.@polly"><code>Base.@polly</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@polly</code></pre><p>Tells the compiler to apply the polyhedral optimizer Polly to a function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L215-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parse-Tuple{AbstractString,Int64}" href="#Base.parse-Tuple{AbstractString,Int64}"><code>Base.parse</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parse(str, start; greedy=true, raise=true)</code></pre><p>Parse the expression string and return an expression (which could later be passed to eval for execution). <code>start</code> is the index of the first character to start parsing. If <code>greedy</code> is <code>true</code> (default), <code>parse</code> will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return <code>Expr(:incomplete, &quot;(error message)&quot;)</code>. If <code>raise</code> is <code>true</code> (default), syntax errors other than incomplete expressions will raise an error. If <code>raise</code> is <code>false</code>, <code>parse</code> will return an expression that will raise an error upon evaluation.</p><pre><code class="language-julia-repl">julia&gt; parse(&quot;x = 3, y = 5&quot;, 7)
(:(y = 5), 13)

julia&gt; parse(&quot;x = 3, y = 5&quot;, 5)
(:((3, y) = 5), 13)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/parse.jl#L253-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parse-Tuple{AbstractString}" href="#Base.parse-Tuple{AbstractString}"><code>Base.parse</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parse(str; raise=true)</code></pre><p>Parse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If <code>raise</code> is <code>true</code> (default), syntax errors will raise an error; otherwise, <code>parse</code> will return an expression that will raise an error upon evaluation.</p><pre><code class="language-julia-repl">julia&gt; parse(&quot;x = 3&quot;)
:(x = 3)

julia&gt; parse(&quot;x = &quot;)
:($(Expr(:incomplete, &quot;incomplete: premature end of input&quot;)))

julia&gt; parse(&quot;1.0.2&quot;)
ERROR: ParseError(&quot;invalid numeric constant \&quot;1.0.\&quot;&quot;)
Stacktrace:
[...]

julia&gt; parse(&quot;1.0.2&quot;; raise = false)
:($(Expr(:error, &quot;invalid numeric constant \&quot;1.0.\&quot;&quot;)))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/parse.jl#L289-L312">source</a></section><h2><a class="nav-anchor" id="Nullables-1" href="#Nullables-1">Nullables</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Nullable" href="#Base.Nullable"><code>Base.Nullable</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Nullable(x, hasvalue::Bool=true)</code></pre><p>Wrap value <code>x</code> in an object of type <code>Nullable</code>, which indicates whether a value is present. <code>Nullable(x)</code> yields a non-empty wrapper and <code>Nullable{T}()</code> yields an empty instance of a wrapper that might contain a value of type <code>T</code>.</p><p><code>Nullable(x, false)</code> yields <code>Nullable{typeof(x)}()</code> with <code>x</code> stored in the result&#39;s <code>value</code> field.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Nullable(1)
Nullable{Int64}(1)

julia&gt; Nullable{Int64}()
Nullable{Int64}()

julia&gt; Nullable(1, false)
Nullable{Int64}()

julia&gt; dump(Nullable(1, false))
Nullable{Int64}
  hasvalue: Bool false
  value: Int64 1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/nullable.jl#L22-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get-Tuple{Nullable,Any}" href="#Base.get-Tuple{Nullable,Any}"><code>Base.get</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get(x::Nullable[, y])</code></pre><p>Attempt to access the value of <code>x</code>. Returns the value if it is present; otherwise, returns <code>y</code> if provided, or throws a <code>NullException</code> if not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; get(Nullable(5))
5

julia&gt; get(Nullable())
ERROR: NullException()
Stacktrace:
 [1] get(::Nullable{Union{}}) at ./nullable.jl:102</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/nullable.jl#L93-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isnull" href="#Base.isnull"><code>Base.isnull</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isnull(x)</code></pre><p>Return whether or not <code>x</code> is null for <a href="base.html#Base.Nullable"><code>Nullable</code></a> <code>x</code>; return <code>false</code> for all other <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = Nullable(1, false)
Nullable{Int64}()

julia&gt; isnull(x)
true

julia&gt; x = Nullable(1, true)
Nullable{Int64}(1)

julia&gt; isnull(x)
false

julia&gt; x = 1
1

julia&gt; isnull(x)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/nullable.jl#L155-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_get" href="#Base.unsafe_get"><code>Base.unsafe_get</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unsafe_get(x)</code></pre><p>Return the value of <code>x</code> for <a href="base.html#Base.Nullable"><code>Nullable</code></a> <code>x</code>; return <code>x</code> for all other <code>x</code>.</p><p>This method does not check whether or not <code>x</code> is null before attempting to access the value of <code>x</code> for <code>x::Nullable</code> (hence &quot;unsafe&quot;).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = Nullable(1)
Nullable{Int64}(1)

julia&gt; unsafe_get(x)
1

julia&gt; x = Nullable{String}()
Nullable{String}()

julia&gt; unsafe_get(x)
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] unsafe_get(::Nullable{String}) at ./nullable.jl:152

julia&gt; x = 1
1

julia&gt; unsafe_get(x)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/nullable.jl#L120-L151">source</a></section><h2><a class="nav-anchor" id="System-1" href="#System-1">System</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.run" href="#Base.run"><code>Base.run</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">run(command, args...)</code></pre><p>Run a command object, constructed with backticks. Throws an error if anything goes wrong, including the process exiting with a non-zero status.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L658-L663">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.spawn" href="#Base.spawn"><code>Base.spawn</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spawn(command)</code></pre><p>Run a command object asynchronously, returning the resulting <code>Process</code> object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L553-L557">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DevNull" href="#Base.DevNull"><code>Base.DevNull</code></a> â <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">DevNull</code></pre><p>Used in a stream redirect to discard all data written to it. Essentially equivalent to /dev/null on Unix or NUL on Windows. Usage:</p><pre><code class="language-julia">run(pipeline(`cat test.txt`, DevNull))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L685-L694">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.success" href="#Base.success"><code>Base.success</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">success(command)</code></pre><p>Run a command object, constructed with backticks, and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L694-L699">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.process_running" href="#Base.process_running"><code>Base.process_running</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">process_running(p::Process)</code></pre><p>Determine whether a process is currently running.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L748-L752">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.process_exited" href="#Base.process_exited"><code>Base.process_exited</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">process_exited(p::Process)</code></pre><p>Determine whether a process has exited.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L757-L761">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.kill-Tuple{Base.Process,Integer}" href="#Base.kill-Tuple{Base.Process,Integer}"><code>Base.kill</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">kill(p::Process, signum=SIGTERM)</code></pre><p>Send a signal to a process. The default is to terminate the process.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L725-L729">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.set_process_title" href="#Base.Sys.set_process_title"><code>Base.Sys.set_process_title</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.set_process_title(title::AbstractString)</code></pre><p>Set the process title. No-op on some operating systems.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L186-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.get_process_title" href="#Base.Sys.get_process_title"><code>Base.Sys.get_process_title</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.get_process_title()</code></pre><p>Get the process title. On some systems, will always return an empty string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L174-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readandwrite" href="#Base.readandwrite"><code>Base.readandwrite</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readandwrite(command)</code></pre><p>Starts running a command asynchronously, and returns a tuple (stdout,stdin,process) of the output stream and input stream of the process, and the process object itself.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L638-L643">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ignorestatus" href="#Base.ignorestatus"><code>Base.ignorestatus</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ignorestatus(command)</code></pre><p>Mark a command object so that running it will not throw an error if the result code is non-zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L180-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.detach" href="#Base.detach"><code>Base.detach</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">detach(command)</code></pre><p>Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L189-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cmd" href="#Base.Cmd"><code>Base.Cmd</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)</code></pre><p>Construct a new <code>Cmd</code> object, representing an external program and arguments, from <code>cmd</code>, while changing the settings of the optional keyword arguments:</p><ul><li><p><code>ignorestatus::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then the <code>Cmd</code> will not throw an error if the return code is nonzero.</p></li><li><p><code>detach::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then the <code>Cmd</code> will be run in a new process group, allowing it to outlive the <code>julia</code> process and not have Ctrl-C passed to it.</p></li><li><p><code>windows_verbatim::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then on Windows the <code>Cmd</code> will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes <code>&quot;</code> in the command line, and <code>\</code> or <code>&quot;</code> are preceded by backslashes. <code>windows_verbatim=true</code> is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</p></li><li><p><code>windows_hide::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then on Windows no new console window is displayed when the <code>Cmd</code> is executed. This has no effect if a console is already open or on non-Windows systems.</p></li><li><p><code>env</code>: Set environment variables to use when running the <code>Cmd</code>. <code>env</code> is either a dictionary mapping strings to strings, an array of strings of the form <code>&quot;var=val&quot;</code>, an array or tuple of <code>&quot;var&quot;=&gt;val</code> pairs, or <code>nothing</code>. In order to modify (rather than replace) the existing environment, create <code>env</code> by <code>copy(ENV)</code> and then set <code>env[&quot;var&quot;]=val</code> as desired.</p></li><li><p><code>dir::AbstractString</code>: Specify a working directory for the command (instead of the current directory).</p></li></ul><p>For any keywords that are not specified, the current settings from <code>cmd</code> are used. Normally, to create a <code>Cmd</code> object in the first place, one uses backticks, e.g.</p><pre><code class="language-none">Cmd(`echo &quot;Hello world&quot;`, ignorestatus=true, detach=false)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L33-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setenv" href="#Base.setenv"><code>Base.setenv</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setenv(command::Cmd, env; dir=&quot;&quot;)</code></pre><p>Set environment variables to use when running the given <code>command</code>. <code>env</code> is either a dictionary mapping strings to strings, an array of strings of the form <code>&quot;var=val&quot;</code>, or zero or more <code>&quot;var&quot;=&gt;val</code> pair arguments. In order to modify (rather than replace) the existing environment, create <code>env</code> by <code>copy(ENV)</code> and then setting <code>env[&quot;var&quot;]=val</code> as desired, or use <code>withenv</code>.</p><p>The <code>dir</code> keyword argument can be used to specify a working directory for the command.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L214-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.withenv" href="#Base.withenv"><code>Base.withenv</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">withenv(f::Function, kv::Pair...)</code></pre><p>Execute <code>f</code> in an environment that is temporarily modified (not replaced as in <code>setenv</code>) by zero or more <code>&quot;var&quot;=&gt;val</code> arguments <code>kv</code>. <code>withenv</code> is generally used via the <code>withenv(kv...) do ... end</code> syntax. A value of <code>nothing</code> can be used to temporarily unset an environment variable (if it is set). When <code>withenv</code> returns, the original environment has been restored.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/env.jl#L143-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pipeline-Tuple{Any,Any,Any,Vararg{Any,N} where N}" href="#Base.pipeline-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>Base.pipeline</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pipeline(from, to, ...)</code></pre><p>Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other <code>pipeline</code> calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example <code>pipeline(a,b,c)</code> is equivalent to <code>pipeline(pipeline(a,b),c)</code>. This provides a more concise way to specify multi-stage pipelines.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">run(pipeline(`ls`, `grep xyz`))
run(pipeline(`ls`, &quot;out.txt&quot;))
run(pipeline(&quot;out.txt&quot;, `grep xyz`))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L283-L300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pipeline-Tuple{Base.AbstractCmd}" href="#Base.pipeline-Tuple{Base.AbstractCmd}"><code>Base.pipeline</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pipeline(command; stdin, stdout, stderr, append=false)</code></pre><p>Redirect I/O to or from the given <code>command</code>. Keyword arguments specify which of the command&#39;s streams should be redirected. <code>append</code> controls whether file output appends to the file. This is a more general version of the 2-argument <code>pipeline</code> function. <code>pipeline(from, to)</code> is equivalent to <code>pipeline(from, stdout=to)</code> when <code>from</code> is a command, and to <code>pipeline(to, stdin=from)</code> when <code>from</code> is another kind of data source.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">run(pipeline(`dothings`, stdout=&quot;out.txt&quot;, stderr=&quot;errs.txt&quot;))
run(pipeline(`update`, stdout=&quot;log.txt&quot;, append=true))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/process.jl#L248-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Libc.gethostname" href="#Base.Libc.gethostname"><code>Base.Libc.gethostname</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gethostname() -&gt; AbstractString</code></pre><p>Get the local machine&#39;s host name.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/libc.jl#L239-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getipaddr" href="#Base.getipaddr"><code>Base.getipaddr</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getipaddr() -&gt; IPAddr</code></pre><p>Get the IP address of the local machine.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/socket.jl#L785-L789">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Libc.getpid" href="#Base.Libc.getpid"><code>Base.Libc.getpid</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getpid() -&gt; Int32</code></pre><p>Get Julia&#39;s process ID.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/libc.jl#L230-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Libc.time-Tuple{}" href="#Base.Libc.time-Tuple{}"><code>Base.Libc.time</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">time()</code></pre><p>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/libc.jl#L221-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.time_ns" href="#Base.time_ns"><code>Base.time_ns</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">time_ns()</code></pre><p>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/util.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@time" href="#Base.@time"><code>Base.@time</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@time</code></pre><p>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.</p><p>See also <a href="base.html#Base.@timev"><code>@timev</code></a>, <a href="base.html#Base.@timed"><code>@timed</code></a>, <a href="base.html#Base.@elapsed"><code>@elapsed</code></a>, and <a href="base.html#Base.@allocated"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @time rand(10^6);
  0.001525 seconds (7 allocations: 7.630 MiB)

julia&gt; @time begin
           sleep(0.3)
           1+1
       end
  0.301395 seconds (8 allocations: 336 bytes)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/util.jl#L139-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@timev" href="#Base.@timev"><code>Base.@timev</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@timev</code></pre><p>This is a verbose version of the <code>@time</code> macro. It first prints the same information as <code>@time</code>, then any non-zero memory allocation counters, and then returns the value of the expression.</p><p>See also <a href="base.html#Base.@time"><code>@time</code></a>, <a href="base.html#Base.@timed"><code>@timed</code></a>, <a href="base.html#Base.@elapsed"><code>@elapsed</code></a>, and <a href="base.html#Base.@allocated"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @timev rand(10^6);
  0.001006 seconds (7 allocations: 7.630 MiB)
elapsed time (ns): 1005567
bytes allocated:   8000256
pool allocs:       6
malloc() calls:    1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/util.jl#L174-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@timed" href="#Base.@timed"><code>Base.@timed</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@timed</code></pre><p>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</p><p>See also <a href="base.html#Base.@time"><code>@time</code></a>, <a href="base.html#Base.@timev"><code>@timev</code></a>, <a href="base.html#Base.@elapsed"><code>@elapsed</code></a>, and <a href="base.html#Base.@allocated"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; val, t, bytes, gctime, memallocs = @timed rand(10^6);

julia&gt; t
0.006634834

julia&gt; bytes
8000256

julia&gt; gctime
0.0055765

julia&gt; fieldnames(typeof(memallocs))
9-element Array{Symbol,1}:
 :allocd
 :malloc
 :realloc
 :poolalloc
 :bigalloc
 :freecall
 :total_time
 :pause
 :full_sweep

julia&gt; memallocs.total_time
5576500</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/util.jl#L264-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@elapsed" href="#Base.@elapsed"><code>Base.@elapsed</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@elapsed</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</p><p>See also <a href="base.html#Base.@time"><code>@time</code></a>, <a href="base.html#Base.@timev"><code>@timev</code></a>, <a href="base.html#Base.@timed"><code>@timed</code></a>, and <a href="base.html#Base.@allocated"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @elapsed sleep(0.3)
0.301391426</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/util.jl#L204-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@allocated" href="#Base.@allocated"><code>Base.@allocated</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@allocated</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the <code>@time</code> macros, which do not try to adjust for the effects of compilation.</p><p>See also <a href="base.html#Base.@time"><code>@time</code></a>, <a href="base.html#Base.@timev"><code>@timev</code></a>, <a href="base.html#Base.@timed"><code>@timed</code></a>, and <a href="base.html#Base.@elapsed"><code>@elapsed</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @allocated rand(10^6)
8000080</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/util.jl#L232-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.EnvHash" href="#Base.EnvHash"><code>Base.EnvHash</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">EnvHash() -&gt; EnvHash</code></pre><p>A singleton of this type provides a hash table interface to environment variables.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/env.jl#L61-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ENV" href="#Base.ENV"><code>Base.ENV</code></a> â <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">ENV</code></pre><p>Reference to the singleton <code>EnvHash</code>, providing a dictionary interface to system environment variables.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/env.jl#L68-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.isunix" href="#Base.Sys.isunix"><code>Base.Sys.isunix</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.isunix([os])</code></pre><p>Predicate for testing if the OS provides a Unix-like interface. See documentation in <a href="../manual/handling-operating-system-variation.html#Handling-Operating-System-Variation-1">Handling Operating System Variation</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L206-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.isapple" href="#Base.Sys.isapple"><code>Base.Sys.isapple</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.isapple([os])</code></pre><p>Predicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in <a href="../manual/handling-operating-system-variation.html#Handling-Operating-System-Variation-1">Handling Operating System Variation</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L246-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.islinux" href="#Base.Sys.islinux"><code>Base.Sys.islinux</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.islinux([os])</code></pre><p>Predicate for testing if the OS is a derivative of Linux. See documentation in <a href="../manual/handling-operating-system-variation.html#Handling-Operating-System-Variation-1">Handling Operating System Variation</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L222-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.isbsd" href="#Base.Sys.isbsd"><code>Base.Sys.isbsd</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.isbsd([os])</code></pre><p>Predicate for testing if the OS is a derivative of BSD. See documentation in <a href="../manual/handling-operating-system-variation.html#Handling-Operating-System-Variation-1">Handling Operating System Variation</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L230-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.iswindows" href="#Base.Sys.iswindows"><code>Base.Sys.iswindows</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.iswindows([os])</code></pre><p>Predicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in <a href="../manual/handling-operating-system-variation.html#Handling-Operating-System-Variation-1">Handling Operating System Variation</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L238-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sys.windows_version" href="#Base.Sys.windows_version"><code>Base.Sys.windows_version</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Sys.windows_version()</code></pre><p>Returns the version number for the Windows NT Kernel as a <code>VersionNumber</code>, i.e. <code>v&quot;major.minor.build&quot;</code>, or <code>v&quot;0.0.0&quot;</code> if this is not running on Windows.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/sysinfo.jl#L266-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@static" href="#Base.@static"><code>Base.@static</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@static</code></pre><p>Partially evaluate an expression at parse time.</p><p>For example, <code>@static Sys.iswindows() ? foo : bar</code> will evaluate <code>Sys.iswindows()</code> and insert either <code>foo</code> or <code>bar</code> into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a <code>ccall</code> to a non-existent function. <code>@static if Sys.isapple() foo end</code> and <code>@static foo &lt;&amp;&amp;,||&gt; bar</code> are also valid syntax.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/osutils.jl#L3-L13">source</a></section><h2><a class="nav-anchor" id="Errors-1" href="#Errors-1">Errors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.error" href="#Base.error"><code>Base.error</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">error(message::AbstractString)</code></pre><p>Raise an <code>ErrorException</code> with the given message.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L28-L32">source</a><div><pre><code class="language-none">error(msg...)</code></pre><p>Raise an <code>ErrorException</code> with the given message.</p><p>See also <a href="io-network.html#Base.logging"><code>logging</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L35-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.throw" href="#Core.throw"><code>Core.throw</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">throw(e)</code></pre><p>Throw an object as an exception.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rethrow" href="#Base.rethrow"><code>Base.rethrow</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rethrow([e])</code></pre><p>Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a <code>catch</code> block).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L47-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.backtrace" href="#Base.backtrace"><code>Base.backtrace</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">backtrace()</code></pre><p>Get a backtrace object for the current program point.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L56-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.catch_backtrace" href="#Base.catch_backtrace"><code>Base.catch_backtrace</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">catch_backtrace()</code></pre><p>Get the backtrace of the current exception, for use within <code>catch</code> blocks.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L63-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.assert" href="#Base.assert"><code>Base.assert</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">assert(cond)</code></pre><p>Throw an <a href="base.html#Core.AssertionError"><code>AssertionError</code></a> if <code>cond</code> is <code>false</code>. Also available as the macro <a href="base.html#Base.@assert"><code>@assert</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L87-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@assert" href="#Base.@assert"><code>Base.@assert</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@assert cond [text]</code></pre><p>Throw an <a href="base.html#Core.AssertionError"><code>AssertionError</code></a> if <code>cond</code> is <code>false</code>. Preferred syntax for writing assertions. Message <code>text</code> is optionally displayed upon assertion failure.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @assert iseven(3) &quot;3 is an odd number!&quot;
ERROR: AssertionError: 3 is an odd number!

julia&gt; @assert isodd(3) &quot;What even are numbers?&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L95-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.ArgumentError" href="#Core.ArgumentError"><code>Core.ArgumentError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ArgumentError(msg)</code></pre><p>The parameters to a function call do not match a valid signature. Argument <code>msg</code> is a descriptive error string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1231-L1236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.AssertionError" href="#Core.AssertionError"><code>Core.AssertionError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AssertionError([msg])</code></pre><p>The asserted condition did not evaluate to <code>true</code>. Optional argument <code>msg</code> is a descriptive error string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1247-L1252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.BoundsError" href="#Core.BoundsError"><code>Core.BoundsError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BoundsError([a],[i])</code></pre><p>An indexing operation into an array, <code>a</code>, tried to access an out-of-bounds element at index <code>i</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = ones(7);

julia&gt; A[8]
ERROR: BoundsError: attempt to access 7-element Array{Float64,1} at index [8]
Stacktrace:
 [1] getindex(::Array{Float64,1}, ::Int64) at ./array.jl:763

julia&gt; B = ones(2, 3);

julia&gt; B[2, 4]
ERROR: BoundsError: attempt to access 2Ã3 Array{Float64,2} at index [2, 4]
Stacktrace:
 [1] getindex(::Array{Float64,2}, ::Int64, ::Int64) at ./array.jl:764

julia&gt; B[9]
ERROR: BoundsError: attempt to access 2Ã3 Array{Float64,2} at index [9]
Stacktrace:
 [1] getindex(::Array{Float64,2}, ::Int64) at ./array.jl:763</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L806-L832">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DimensionMismatch" href="#Base.DimensionMismatch"><code>Base.DimensionMismatch</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DimensionMismatch([msg])</code></pre><p>The objects called do not have matching dimensionality. Optional argument <code>msg</code> is a descriptive error string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/array.jl#L5-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.DivideError" href="#Core.DivideError"><code>Core.DivideError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DivideError()</code></pre><p>Integer division was attempted with a denominator value of 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 2/0
Inf

julia&gt; div(2, 0)
ERROR: DivideError: integer division error
Stacktrace:
 [1] div(::Int64, ::Int64) at ./int.jl:220</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L979-L994">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.DomainError" href="#Core.DomainError"><code>Core.DomainError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DomainError(val)
DomainError(val, msg)</code></pre><p>The argument <code>val</code> to a function or constructor is outside the valid domain.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
 [2] sqrt at ./math.jl:462 [inlined]
 [3] sqrt(::Int64) at ./math.jl:472</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L850-L866">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.EOFError" href="#Base.EOFError"><code>Base.EOFError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">EOFError()</code></pre><p>No more data was available to read from a file or stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/io.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.ErrorException" href="#Core.ErrorException"><code>Core.ErrorException</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ErrorException(msg)</code></pre><p>Generic error type. The error message, in the <code>.msg</code> field, may provide more specific details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L746-L750">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.InexactError" href="#Core.InexactError"><code>Core.InexactError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">InexactError(name::Symbol, T, val)</code></pre><p>Cannot exactly convert <code>val</code> to type <code>T</code> in a method of function <code>name</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Float64, 1+2im)
ERROR: InexactError: convert(Float64, 1 + 2im)
Stacktrace:
 [1] convert(::Type{Float64}, ::Complex{Int64}) at ./complex.jl:37</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L835-L847">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.InterruptException" href="#Core.InterruptException"><code>Core.InterruptException</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">InterruptException()</code></pre><p>The process was stopped by a terminal interrupt (CTRL+C).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L922-L926">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.KeyError" href="#Base.KeyError"><code>Base.KeyError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">KeyError(key)</code></pre><p>An indexing operation into an <code>Associative</code> (<code>Dict</code>) or <code>Set</code> like object tried to access or delete a non-existent element.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/associative.jl#L5-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.LoadError" href="#Core.LoadError"><code>Core.LoadError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LoadError(file::AbstractString, line::Int, error)</code></pre><p>An error occurred while <code>include</code>ing, <code>require</code>ing, or <code>using</code> a file. The error specifics should be available in the <code>.error</code> field.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1255-L1260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.MethodError" href="#Core.MethodError"><code>Core.MethodError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MethodError(f, args)</code></pre><p>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1239-L1244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.NullException" href="#Base.NullException"><code>Base.NullException</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NullException()</code></pre><p>An attempted access to a <a href="base.html#Base.Nullable"><code>Nullable</code></a> with no defined value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Nullable{Int}()
Nullable{Int64}()

julia&gt; get(a)
ERROR: NullException()
Stacktrace:
 [1] get(::Nullable{Int64}) at ./nullable.jl:118</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/nullable.jl#L3-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.OutOfMemoryError" href="#Core.OutOfMemoryError"><code>Core.OutOfMemoryError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">OutOfMemoryError()</code></pre><p>An operation allocated too much memory for either the system or the garbage collector to handle properly.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L798-L803">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.ReadOnlyMemoryError" href="#Core.ReadOnlyMemoryError"><code>Core.ReadOnlyMemoryError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ReadOnlyMemoryError()</code></pre><p>An operation tried to write to memory that is read-only.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L739-L743">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.OverflowError" href="#Core.OverflowError"><code>Core.OverflowError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">OverflowError(msg)</code></pre><p>The result of an expression is too large for the specified type and will cause a wraparound.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L908-L912">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ParseError" href="#Base.ParseError"><code>Base.ParseError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ParseError(msg)</code></pre><p>The expression passed to the <code>parse</code> function could not be interpreted as a valid Julia expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/parse.jl#L243-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Distributed.ProcessExitedException" href="#Base.Distributed.ProcessExitedException"><code>Base.Distributed.ProcessExitedException</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ProcessExitedException()</code></pre><p>After a client Julia process has exited, further attempts to reference the dead child will throw this exception.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/distributed/cluster.jl#L888-L893">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.StackOverflowError" href="#Core.StackOverflowError"><code>Core.StackOverflowError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">StackOverflowError()</code></pre><p>The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L886-L891">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SystemError" href="#Base.SystemError"><code>Base.SystemError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SystemError(prefix::AbstractString, [errno::Int32])</code></pre><p>A system call failed with an error code (in the <code>errno</code> global variable).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/io.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.TypeError" href="#Core.TypeError"><code>Core.TypeError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TypeError(func::Symbol, context::AbstractString, expected::Type, got)</code></pre><p>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L915-L919">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.UndefRefError" href="#Core.UndefRefError"><code>Core.UndefRefError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">UndefRefError()</code></pre><p>The item or field is not defined for the given object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L753-L757">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.UndefVarError" href="#Core.UndefVarError"><code>Core.UndefVarError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">UndefVarError(var::Symbol)</code></pre><p>A symbol in the current scope is not defined.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L901-L905">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.InitError" href="#Core.InitError"><code>Core.InitError</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">InitError(mod::Symbol, error)</code></pre><p>An error occurred when running a module&#39;s <code>__init__</code> function. The actual error thrown is available in the <code>.error</code> field.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1263-L1268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.retry" href="#Base.retry"><code>Base.retry</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">retry(f::Function;  delays=ExponentialBackOff(), check=nothing) -&gt; Function</code></pre><p>Returns an anonymous function that calls function <code>f</code>.  If an exception arises, <code>f</code> is repeatedly called again, each time <code>check</code> returns <code>true</code>, after waiting the number of seconds specified in <code>delays</code>.  <code>check</code> should input <code>delays</code>&#39;s current state and the <code>Exception</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">retry(f, delays=fill(5.0, 3))
retry(f, delays=rand(5:10, 2))
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))
retry(http_get, check=(s,e)-&gt;e.status == &quot;503&quot;)(url)
retry(read, check=(s,e)-&gt;isa(e, UVError))(io, 128; all=false)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L157-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ExponentialBackOff" href="#Base.ExponentialBackOff"><code>Base.ExponentialBackOff</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)</code></pre><p>A <a href="numbers.html#Core.Float64"><code>Float64</code></a> iterator of length <code>n</code> whose elements exponentially increase at a rate in the interval <code>factor</code> * (1 Â± <code>jitter</code>).  The first element is <code>first_delay</code> and all elements are clamped to <code>max_delay</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/error.jl#L138-L144">source</a></section><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Timer-Tuple{Function,Real,Real}" href="#Base.Timer-Tuple{Function,Real,Real}"><code>Base.Timer</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Timer(callback::Function, delay, repeat=0)</code></pre><p>Create a timer to call the given <code>callback</code> function. The <code>callback</code> is passed one argument, the timer object itself. The callback will be invoked after the specified initial <code>delay</code>, and then repeating with the given <code>repeat</code> interval. If <code>repeat</code> is <code>0</code>, the timer is only triggered once. Times are in seconds. A timer is stopped and has its resources freed by calling <a href="io-network.html#Base.close"><code>close</code></a> on it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/event.jl#L447-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Timer" href="#Base.Timer"><code>Base.Timer</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Timer(delay, repeat=0)</code></pre><p>Create a timer that wakes up tasks waiting for it (by calling <a href="parallel.html#Base.wait"><code>wait</code></a> on the timer object) at a specified interval.  Times are in seconds.  Waiting tasks are woken with an error when the timer is closed (by <a href="io-network.html#Base.close"><code>close</code></a>. Use <a href="io-network.html#Base.isopen"><code>isopen</code></a> to check whether a timer is still active.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/event.jl#L347-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.AsyncCondition" href="#Base.AsyncCondition"><code>Base.AsyncCondition</code></a> â <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AsyncCondition()</code></pre><p>Create a async condition that wakes up tasks waiting for it (by calling <a href="parallel.html#Base.wait"><code>wait</code></a> on the object) when notified from C by a call to <code>uv_async_send</code>. Waiting tasks are woken with an error when the object is closed (by <a href="io-network.html#Base.close"><code>close</code></a>. Use <a href="io-network.html#Base.isopen"><code>isopen</code></a> to check whether it is still active.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/event.jl#L290-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.AsyncCondition-Tuple{Function}" href="#Base.AsyncCondition-Tuple{Function}"><code>Base.AsyncCondition</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">AsyncCondition(callback::Function)</code></pre><p>Create a async condition that calls the given <code>callback</code> function. The <code>callback</code> is passed one argument, the async condition object itself.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/event.jl#L320-L325">source</a></section><h2><a class="nav-anchor" id="Reflection-1" href="#Reflection-1">Reflection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.module_name" href="#Base.module_name"><code>Base.module_name</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">module_name(m::Module) -&gt; Symbol</code></pre><p>Get the name of a <code>Module</code> as a <code>Symbol</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; module_name(Base.LinAlg)
:LinAlg</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L5-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.module_parent" href="#Base.module_parent"><code>Base.module_parent</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">module_parent(m::Module) -&gt; Module</code></pre><p>Get a module&#39;s enclosing <code>Module</code>. <code>Main</code> is its own parent, as is <code>LastMain</code> after <code>workspace()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; module_parent(Main)
Main

julia&gt; module_parent(Base.LinAlg.BLAS)
Base.LinAlg</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L18-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@__MODULE__" href="#Base.@__MODULE__"><code>Base.@__MODULE__</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@__MODULE__ -&gt; Module</code></pre><p>Get the <code>Module</code> of the toplevel eval, which is the <code>Module</code> code is currently being read from.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L34-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fullname" href="#Base.fullname"><code>Base.fullname</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fullname(m::Module)</code></pre><p>Get the fully-qualified name of a module as a tuple of symbols. For example,</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fullname(Base.Pkg)
(:Base, :Pkg)

julia&gt; fullname(Main)
()</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L44-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.names" href="#Base.names"><code>Base.names</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">names(x::Module, all::Bool=false, imported::Bool=false)</code></pre><p>Get an array of the names exported by a <code>Module</code>, excluding deprecated names. If <code>all</code> is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If <code>imported</code> is true, then names explicitly imported from other modules are also included.</p><p>As a special case, all names defined in <code>Main</code> are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from <code>Main</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L84-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.nfields" href="#Core.nfields"><code>Core.nfields</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nfields(x) -&gt; Int</code></pre><p>Get the number of fields in the given object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L894-L898">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fieldnames" href="#Base.fieldnames"><code>Base.fieldnames</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fieldnames(x::DataType)</code></pre><p>Get an array of the fields of a <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fieldnames(Hermitian)
2-element Array{Symbol,1}:
 :data
 :uplo</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L134-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fieldname" href="#Base.fieldname"><code>Base.fieldname</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fieldname(x::DataType, i::Integer)</code></pre><p>Get the name of field <code>i</code> of a <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fieldname(SparseMatrixCSC, 1)
:m

julia&gt; fieldname(SparseMatrixCSC, 5)
:nzval</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L115-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fieldcount" href="#Base.fieldcount"><code>Base.fieldcount</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fieldcount(t::Type)</code></pre><p>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L459-L464">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.datatype_module" href="#Base.datatype_module"><code>Base.datatype_module</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.datatype_module(t::DataType) -&gt; Module</code></pre><p>Determine the module containing the definition of a (potentially UnionAll-wrapped) <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; module Foo
           struct Int end
       end
Foo

julia&gt; Base.datatype_module(Int)
Core

julia&gt; Base.datatype_module(Foo.Int)
Foo</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L171-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.datatype_name" href="#Base.datatype_name"><code>Base.datatype_name</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.datatype_name(t) -&gt; Symbol</code></pre><p>Get the name of a (potentially UnionAll-wrapped) <code>DataType</code> (without its parent module) as a symbol.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; module Foo
           struct S{T}
           end
       end
Foo

julia&gt; Base.datatype_name(Foo.S{T} where T)
:S</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L151-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isconst" href="#Base.isconst"><code>Base.isconst</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isconst(m::Module, s::Symbol) -&gt; Bool</code></pre><p>Determine whether a global is declared <code>const</code> in a given <code>Module</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L193-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.function_name" href="#Base.function_name"><code>Base.function_name</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.function_name(f::Function) -&gt; Symbol</code></pre><p>Get the name of a generic <code>Function</code> as a symbol, or <code>:anonymous</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L934-L938">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.function_module-Tuple{Function}" href="#Base.function_module-Tuple{Function}"><code>Base.function_module</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Base.function_module(f::Function) -&gt; Module</code></pre><p>Determine the module containing the (first) definition of a generic function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L978-L983">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.function_module-Tuple{Any,Any}" href="#Base.function_module-Tuple{Any,Any}"><code>Base.function_module</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Base.function_module(f::Function, types) -&gt; Module</code></pre><p>Determine the module containing a given definition of a generic function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L986-L990">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.functionloc-Tuple{Any,Any}" href="#Base.functionloc-Tuple{Any,Any}"><code>Base.functionloc</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">functionloc(f::Function, types)</code></pre><p>Returns a tuple <code>(filename,line)</code> giving the location of a generic <code>Function</code> definition.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L956-L960">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.functionloc-Tuple{Method}" href="#Base.functionloc-Tuple{Method}"><code>Base.functionloc</code></a> â <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">functionloc(m::Method)</code></pre><p>Returns a tuple <code>(filename,line)</code> giving the location of a <code>Method</code> definition.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L943-L947">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@functionloc" href="#Base.@functionloc"><code>Base.@functionloc</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@functionloc</code></pre><p>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple <code>(filename,line)</code> giving the location for the method that would be called for those arguments. It calls out to the <code>functionloc</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L506-L512">source</a></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.gc" href="#Base.gc"><code>Base.gc</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gc()</code></pre><p>Perform garbage collection. This should not generally be used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/gcutils.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.gc_enable" href="#Base.gc_enable"><code>Base.gc_enable</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gc_enable(on::Bool)</code></pre><p>Control whether garbage collection is enabled using a boolean argument (<code>true</code> for enabled, <code>false</code> for disabled). Returns previous GC state. Disabling garbage collection should be used only with extreme caution, as it can cause memory use to grow without bound.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/gcutils.jl#L46-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.macroexpand" href="#Base.macroexpand"><code>Base.macroexpand</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">macroexpand(m::Module, x; recursive=true)</code></pre><p>Takes the expression <code>x</code> and returns an equivalent expression with all macros removed (expanded) for executing in module <code>m</code>. The <code>recursive</code> keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:</p><pre><code class="language-julia-repl">julia&gt; module M
           macro m1()
               42
           end
           macro m2()
               :(@m1())
           end
       end
M

julia&gt; macroexpand(M, :(@m2()), recursive=true)
42

julia&gt; macroexpand(M, :(@m2()), recursive=false)
:(#= REPL[16]:6 =# M.@m1)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L57-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@macroexpand" href="#Base.@macroexpand"><code>Base.@macroexpand</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@macroexpand</code></pre><p>Return equivalent expression with all macros removed (expanded).</p><p>There are differences between <code>@macroexpand</code> and <a href="base.html#Base.macroexpand"><code>macroexpand</code></a>.</p><ul><li><p>While <a href="base.html#Base.macroexpand"><code>macroexpand</code></a> takes a keyword argument <code>recursive</code>, <code>@macroexpand</code></p></li></ul><p>is always recursive. For a non recursive macro version, see <a href="base.html#Base.@macroexpand1"><code>@macroexpand1</code></a>.</p><ul><li><p>While <a href="base.html#Base.macroexpand"><code>macroexpand</code></a> has an explicit <code>module</code> argument, <code>@macroexpand</code> always</p></li></ul><p>expands with respect to the module in which it is called. This is best seen in the following example:</p><pre><code class="language-julia-repl">julia&gt; module M
           macro m()
               1
           end
           function f()
               (@macroexpand(@m),
                macroexpand(M, :(@m)),
                macroexpand(Main, :(@m))
               )
           end
       end
M

julia&gt; macro m()
           2
       end
@m (macro with 1 method)

julia&gt; M.f()
(1, 1, 2)</code></pre><p>With <code>@macroexpand</code> the expression expands where <code>@macroexpand</code> appears in the code (module <code>M</code> in the example). With <code>macroexpand</code> the expression expands in the module given as the first argument.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L90-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@macroexpand1" href="#Base.@macroexpand1"><code>Base.@macroexpand1</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@macroexpand1</code></pre><p>Non recursive version of <a href="base.html#Base.@macroexpand"><code>@macroexpand</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L133-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.expand" href="#Base.expand"><code>Base.expand</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">expand(m, x)</code></pre><p>Takes the expression <code>x</code> and returns an equivalent expression in lowered form for executing in module <code>m</code>. See also <a href="base.html#Base.code_lowered"><code>code_lowered</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/expr.jl#L48-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.code_lowered" href="#Base.code_lowered"><code>Base.code_lowered</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">code_lowered(f, types, expand_generated = true)</code></pre><p>Return an array of lowered ASTs for the methods matching the given generic function and type signature.</p><p>If <code>expand_generated</code> is <code>false</code>, then the <code>CodeInfo</code> instances returned for <code>@generated</code> methods will correspond to the generators&#39; lowered ASTs. If <code>expand_generated</code> is <code>true</code>, these <code>CodeInfo</code> instances will correspond to the lowered ASTs of the method bodies yielded by expanding the generators.</p><p>Note that an error will be thrown if <code>types</code> are not leaf types when <code>expand_generated</code> is <code>true</code> and the corresponding method is a <code>@generated</code> method.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L592-L604">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@code_lowered" href="#Base.@code_lowered"><code>Base.@code_lowered</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@code_lowered</code></pre><p>Evaluates the arguments to the function or macro call, determines their types, and calls <a href="base.html#Base.code_lowered"><code>code_lowered</code></a> on the resulting expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L531-L536">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.code_typed" href="#Base.code_typed"><code>Base.code_typed</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">code_typed(f, types; optimize=true)</code></pre><p>Returns an array of lowered and type-inferred ASTs for the methods matching the given generic function and type signature. The keyword argument <code>optimize</code> controls whether additional optimizations, such as inlining, are also applied.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L856-L862">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@code_typed" href="#Base.@code_typed"><code>Base.@code_typed</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@code_typed</code></pre><p>Evaluates the arguments to the function or macro call, determines their types, and calls <a href="base.html#Base.code_typed"><code>code_typed</code></a> on the resulting expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L515-L520">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.code_warntype" href="#Base.code_warntype"><code>Base.code_warntype</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">code_warntype([io::IO], f, types)</code></pre><p>Prints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to <code>io</code> which defaults to <code>STDOUT</code>. The ASTs are annotated in such a way as to cause &quot;non-leaf&quot; types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. See <a href="../manual/performance-tips.html#man-code-warntype-1"><code>@code_warntype</code></a> for more information.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L344-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@code_warntype" href="#Base.@code_warntype"><code>Base.@code_warntype</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@code_warntype</code></pre><p>Evaluates the arguments to the function or macro call, determines their types, and calls <a href="base.html#Base.code_warntype"><code>code_warntype</code></a> on the resulting expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L523-L528">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.code_llvm" href="#Base.code_llvm"><code>Base.code_llvm</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">code_llvm([io=STDOUT,], f, types)</code></pre><p>Prints the LLVM bitcodes generated for running the method matching the given generic function and type signature to <code>io</code>.</p><p>All metadata and dbg.* calls are removed from the printed bitcode. Use code_llvm_raw for the full IR.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L822-L829">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@code_llvm" href="#Base.@code_llvm"><code>Base.@code_llvm</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@code_llvm</code></pre><p>Evaluates the arguments to the function or macro call, determines their types, and calls <a href="base.html#Base.code_llvm"><code>code_llvm</code></a> on the resulting expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L539-L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.code_native" href="#Base.code_native"><code>Base.code_native</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">code_native([io=STDOUT,], f, types, syntax=:att)</code></pre><p>Prints the native assembly instructions generated for running the method matching the given generic function and type signature to <code>io</code>. Switch assembly syntax using <code>syntax</code> symbol parameter set to <code>:att</code> for AT&amp;T syntax or <code>:intel</code> for Intel syntax.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/reflection.jl#L835-L841">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@code_native" href="#Base.@code_native"><code>Base.@code_native</code></a> â <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@code_native</code></pre><p>Evaluates the arguments to the function or macro call, determines their types, and calls <a href="base.html#Base.code_native"><code>code_native</code></a> on the resulting expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/interactiveutil.jl#L547-L552">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.precompile" href="#Base.precompile"><code>Base.precompile</code></a> â <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">precompile(f, args::Tuple{Vararg{Any}})</code></pre><p>Compile the given function <code>f</code> for the argument tuple (of types) <code>args</code>, but do not execute it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/essentials.jl#L393-L397">source</a></section><footer><hr/><a class="previous" href="../manual/unicode-input.html"><span class="direction">Previous</span><span class="title">Unicode Input</span></a><a class="next" href="collections.html"><span class="direction">Next</span><span class="title">Collections and Data Structures</span></a></footer></article></body></html>
