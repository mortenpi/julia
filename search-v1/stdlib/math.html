<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematics · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="collections.html">Collections and Data Structures</a></li><li class="current"><a class="toctext" href="math.html">Mathematics</a><ul class="internal"><li><a class="toctext" href="#math-ops-1">Mathematical Operators</a></li><li><a class="toctext" href="#Mathematical-Functions-1">Mathematical Functions</a></li><li><a class="toctext" href="#Statistics-1">Statistics</a></li></ul></li><li><a class="toctext" href="numbers.html">Numbers</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="file.html">Filesystem</a></li><li><a class="toctext" href="io-network.html">I/O and Network</a></li><li><a class="toctext" href="punctuation.html">Punctuation</a></li><li><a class="toctext" href="sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="dates.html">Dates and Time</a></li><li><a class="toctext" href="iterators.html">Iteration utilities</a></li><li><a class="toctext" href="test.html">Unit Testing</a></li><li><a class="toctext" href="c.html">C Interface</a></li><li><a class="toctext" href="libc.html">C Standard Library</a></li><li><a class="toctext" href="libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">StackTraces</a></li><li><a class="toctext" href="simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href="math.html">Mathematics</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/doc/src/stdlib/math.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mathematics</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Mathematics-1" href="#Mathematics-1">Mathematics</a></h1><h2><a class="nav-anchor" id="math-ops-1" href="#math-ops-1">Mathematical Operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Any}" href="#Base.:--Tuple{Any}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">-(x)</code></pre><p>Unary minus operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1202-L1206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+" href="#Base.:+"><code>Base.:+</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">+(x, y...)</code></pre><p>Addition operator. <code>x+y+z+...</code> calls this function with all arguments, i.e. <code>+(x, y, z, ...)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1195-L1199">source</a><div><pre><code class="language-none">dt::Date + t::Time -&gt; DateTime</code></pre><p>The addition of a <code>Date</code> with a <code>Time</code> produces a <code>DateTime</code>. The hour, minute, second, and millisecond parts of the <code>Time</code> are used along with the year, month, and day of the <code>Date</code> to create the new <code>DateTime</code>. Non-zero microseconds or nanoseconds in the <code>Time</code> type will result in an <code>InexactError</code> being thrown.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/dates/arithmetic.jl#L12-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Any,Any}" href="#Base.:--Tuple{Any,Any}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">-(x, y)</code></pre><p>Subtraction operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1209-L1213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Any,Vararg{Any,N} where N}" href="#Base.:*-Tuple{Any,Vararg{Any,N} where N}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">*(x, y...)</code></pre><p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1216-L1220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/" href="#Base.:/"><code>Base.:/</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">/(x, y)</code></pre><p>Right division operator: multiplication of <code>x</code> by the inverse of <code>y</code> on the right. Gives floating-point results for integer arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L1223-L1228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{Any,Any}" href="#Base.:\\-Tuple{Any,Any}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">\(x, y)</code></pre><p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [1 2; 3 4]; x = [5, 6];

julia&gt; A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia&gt; inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L474-L500">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:^-Tuple{Number,Number}" href="#Base.:^-Tuple{Number,Number}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">^(x, y)</code></pre><p>Exponentiation operator. If <code>x</code> is a matrix, computes matrix exponentiation.</p><p>If <code>y</code> is an <code>Int</code> literal (e.g. <code>2</code> in <code>x^2</code> or <code>-3</code> in <code>x^-3</code>), the Julia code <code>x^y</code> is transformed by the compiler to <code>Base.literal_pow(^, x, Val(y))</code>, to enable compile-time specialization on the value of the exponent. (As a default fallback we have <code>Base.literal_pow(^, x, Val(y)) = ^(x,y)</code>, where usually <code>^ == Base.^</code> unless <code>^</code> has been defined in the calling namespace.)</p><pre><code class="language-julia-repl">julia&gt; 3^5
243

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; A^3
2×2 Array{Int64,2}:
 37   54
 81  118</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/promotion.jl#L281-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fma" href="#Base.fma"><code>Base.fma</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fma(x, y, z)</code></pre><p>Computes <code>x*y+z</code> without rounding the intermediate result <code>x*y</code>. On some systems this is significantly more expensive than <code>x*y+z</code>. <code>fma</code> is used to improve accuracy in certain algorithms. See <a href="math.html#Base.muladd"><code>muladd</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/floatfuncs.jl#L241-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.muladd" href="#Base.muladd"><code>Base.muladd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">muladd(x, y, z)</code></pre><p>Combined multiply-add, computes <code>x*y+z</code> allowing the add and multiply to be contracted with each other or ones from other <code>muladd</code> and <code>@fastmath</code> to form <code>fma</code> if the transformation can improve performance. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See <a href="math.html#Base.fma"><code>fma</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; muladd(3, 2, 1)
7

julia&gt; 3 * 2 + 1
7</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L966-L984">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Number}" href="#Base.inv-Tuple{Number}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">inv(x)</code></pre><p>Return the multiplicative inverse of <code>x</code>, such that <code>x*inv(x)</code> or <code>inv(x)*x</code> yields <a href="numbers.html#Base.one"><code>one(x)</code></a> (the multiplicative identity) up to roundoff errors.</p><p>If <code>x</code> is a number, this is essentially the same as <code>one(x)/x</code>, but for some types <code>inv(x)</code> may be slightly more efficient.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; inv(2)
0.5

julia&gt; inv(1 + 2im)
0.2 - 0.4im

julia&gt; inv(1 + 2im) * (1 + 2im)
1.0 + 0.0im

julia&gt; inv(2//3)
3//2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L172-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.div" href="#Base.div"><code>Base.div</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">div(x, y)
÷(x, y)</code></pre><p>The quotient from Euclidean division. Computes <code>x/y</code>, truncated to an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 9 ÷ 4
2

julia&gt; -5 ÷ 3
-1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L666-L680">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fld" href="#Base.fld"><code>Base.fld</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fld(x, y)</code></pre><p>Largest integer less than or equal to <code>x/y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fld(7.3,5.5)
1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L614-L624">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cld" href="#Base.cld"><code>Base.cld</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cld(x, y)</code></pre><p>Smallest integer larger than or equal to <code>x/y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cld(5.5,2.2)
3.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L627-L637">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mod" href="#Base.mod"><code>Base.mod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mod(x, y)
rem(x, y, RoundDown)</code></pre><p>The reduction of <code>x</code> modulo <code>y</code>, or equivalently, the remainder of <code>x</code> after floored division by <code>y</code>, i.e.</p><pre><code class="language-julia">x - y*fld(x,y)</code></pre><p>if computed without intermediate rounding.</p><p>The result will have the same sign as <code>y</code>, and magnitude less than <code>abs(y)</code> (with some exceptions, see note below).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to <code>y</code>, then it may be rounded to <code>y</code>.</p></div></div><pre><code class="language-julia-repl">julia&gt; mod(8, 3)
2

julia&gt; mod(9, 3)
0

julia&gt; mod(8.9, 3)
2.9000000000000004

julia&gt; mod(eps(), 3)
2.220446049250313e-16

julia&gt; mod(-eps(), 3)
3.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L169-L205">source</a><div><pre><code class="language-none">rem(x::Integer, T::Type{&lt;:Integer}) -&gt; T
mod(x::Integer, T::Type{&lt;:Integer}) -&gt; T
%(x::Integer, T::Type{&lt;:Integer}) -&gt; T</code></pre><p>Find <code>y::T</code> such that <code>x</code> ≡ <code>y</code> (mod n), where n is the number of integers representable in <code>T</code>, and <code>y</code> is an integer in <code>[typemin(T),typemax(T)]</code>. If <code>T</code> can represent any integer (e.g. <code>T == BigInt</code>), then this operation corresponds to a conversion to <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; 129 % Int8
-127</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L501-L515">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rem" href="#Base.rem"><code>Base.rem</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rem(x, y)
%(x, y)</code></pre><p>Remainder from Euclidean division, returning a value of the same sign as <code>x</code>, and smaller in magnitude than <code>y</code>. This value is always exact.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = 15; y = 4;

julia&gt; x % y
3

julia&gt; x == div(x, y) * y + rem(x, y)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L645-L662">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.rem2pi" href="#Base.Math.rem2pi"><code>Base.Math.rem2pi</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rem2pi(x, r::RoundingMode)</code></pre><p>Compute the remainder of <code>x</code> after integer division by <code>2π</code>, with the quotient rounded according to the rounding mode <code>r</code>. In other words, the quantity</p><pre><code class="language-none">x - 2π*round(x/(2π),r)</code></pre><p>without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than <code>rem(x,2π,r)</code></p><ul><li><p>if <code>r == RoundNearest</code>, then the result is in the interval <span>$[-π, π]$</span>. This will generally be the most accurate result.</p></li><li><p>if <code>r == RoundToZero</code>, then the result is in the interval <span>$[0, 2π]$</span> if <code>x</code> is positive,. or <span>$[-2π, 0]$</span> otherwise.</p></li><li><p>if <code>r == RoundDown</code>, then the result is in the interval <span>$[0, 2π]$</span>.</p></li><li><p>if <code>r == RoundUp</code>, then the result is in the interval <span>$[-2π, 0]$</span>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia&gt; rem2pi(7pi/4, RoundDown)
5.497787143782138</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L800-L829">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.mod2pi" href="#Base.Math.mod2pi"><code>Base.Math.mod2pi</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mod2pi(x)</code></pre><p>Modulus after division by <code>2π</code>, returning in the range <span>$[0,2π)$</span>.</p><p>This function computes a floating point representation of the modulus after division by numerically exact <code>2π</code>, and is therefore not exactly the same as <code>mod(x,2π)</code>, which would compute the modulus of <code>x</code> relative to division by the floating-point number <code>2π</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mod2pi(9*pi/4)
0.7853981633974481</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L947-L961">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.divrem" href="#Base.divrem"><code>Base.divrem</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">divrem(x, y)</code></pre><p>The quotient and remainder from Euclidean division. Equivalent to <code>(div(x,y), rem(x,y))</code> or <code>(x÷y, x%y)</code>.</p><pre><code class="language-julia-repl">julia&gt; divrem(3,7)
(0, 3)

julia&gt; divrem(7,3)
(2, 1)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L69-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fldmod" href="#Base.fldmod"><code>Base.fldmod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fldmod(x, y)</code></pre><p>The floored quotient and modulus after division. Equivalent to <code>(fld(x,y), mod(x,y))</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L85-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fld1" href="#Base.fld1"><code>Base.fld1</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fld1(x, y)</code></pre><p>Flooring division, returning a value consistent with <code>mod1(x,y)</code></p><p>See also: <a href="math.html#Base.mod1"><code>mod1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = 15; y = 4;

julia&gt; fld1(x, y)
4

julia&gt; x == fld(x, y) * y + mod(x, y)
true

julia&gt; x == (fld1(x, y) - 1) * y + mod1(x, y)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L704-L724">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mod1" href="#Base.mod1"><code>Base.mod1</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mod1(x, y)</code></pre><p>Modulus after flooring division, returning a value <code>r</code> such that <code>mod(r, y) == mod(x, y)</code> in the range <span>$(0, y]$</span> for positive <code>y</code> and in the range <span>$[y,0)$</span> for negative <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mod1(4, 2)
2

julia&gt; mod1(4, 3)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L684-L698">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fldmod1" href="#Base.fldmod1"><code>Base.fldmod1</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fldmod1(x, y)</code></pre><p>Return <code>(fld1(x,y), mod1(x,y))</code>.</p><p>See also: <a href="math.html#Base.fld1"><code>fld1</code></a>, <a href="math.html#Base.mod1"><code>mod1</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L729-L735">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.://" href="#Base.://"><code>Base.://</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">//(num, den)</code></pre><p>Divide two integers or rational numbers, giving a <a href="numbers.html#Base.Rational"><code>Rational</code></a> result.</p><pre><code class="language-julia-repl">julia&gt; 3 // 5
3//5

julia&gt; (3 // 5) // (2 // 1)
3//10</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rational.jl#L27-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rationalize" href="#Base.rationalize"><code>Base.rationalize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rationalize([T&lt;:Integer=Int,] x; tol::Real=eps(x))</code></pre><p>Approximate floating point number <code>x</code> as a <a href="numbers.html#Base.Rational"><code>Rational</code></a> number with components of the given integer type. The result will differ from <code>x</code> by no more than <code>tol</code>.</p><pre><code class="language-julia-repl">julia&gt; rationalize(5.6)
28//5

julia&gt; a = rationalize(BigInt, 10.3)
103//10

julia&gt; typeof(numerator(a))
BigInt</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rational.jl#L112-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.numerator" href="#Base.numerator"><code>Base.numerator</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">numerator(x)</code></pre><p>Numerator of the rational representation of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; numerator(2//3)
2

julia&gt; numerator(4)
4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rational.jl#L191-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.denominator" href="#Base.denominator"><code>Base.denominator</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">denominator(x)</code></pre><p>Denominator of the rational representation of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; denominator(2//3)
3

julia&gt; denominator(4)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rational.jl#L207-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;&lt;" href="#Base.:&lt;&lt;"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&lt;&lt;(x, n)</code></pre><p>Left bit shift operator, <code>x &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted left by <code>n</code> bits, filling with <code>0</code>s. This is equivalent to <code>x * 2^n</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &gt;&gt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Int8(3) &lt;&lt; 2
12

julia&gt; bits(Int8(3))
&quot;00000011&quot;

julia&gt; bits(Int8(12))
&quot;00001100&quot;</code></pre><p>See also <a href="math.html#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="math.html#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L507-L526">source</a><div><pre><code class="language-none">&lt;&lt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Left bit shift operator, <code>B &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions backwards, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted forwards. Equivalent to <code>B &gt;&gt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia&gt; B &lt;&lt; 1
5-element BitArray{1}:
 false
  true
 false
 false
 false

julia&gt; B &lt;&lt; -1
5-element BitArray{1}:
 false
  true
 false
  true
 false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/bitarray.jl#L1424-L1458">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;&gt;" href="#Base.:&gt;&gt;"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&gt;&gt;(x, n)</code></pre><p>Right bit shift operator, <code>x &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s if <code>x &gt;= 0</code>, <code>1</code>s if <code>x &lt; 0</code>, preserving the sign of <code>x</code>. This is equivalent to <code>fld(x, 2^n)</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Int8(13) &gt;&gt; 2
3

julia&gt; bits(Int8(13))
&quot;00001101&quot;

julia&gt; bits(Int8(3))
&quot;00000011&quot;

julia&gt; Int8(-14) &gt;&gt; 2
-4

julia&gt; bits(Int8(-14))
&quot;11110010&quot;

julia&gt; bits(Int8(-4))
&quot;11111100&quot;</code></pre><p>See also <a href="math.html#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>, <a href="math.html#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L536-L565">source</a><div><pre><code class="language-none">&gt;&gt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Right bit shift operator, <code>B &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions forward, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted backwards. Equivalent to <code>B &lt;&lt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia&gt; B &gt;&gt; 1
5-element BitArray{1}:
 false
  true
 false
  true
 false

julia&gt; B &gt;&gt; -1
5-element BitArray{1}:
 false
  true
 false
 false
 false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/bitarray.jl#L1386-L1420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;&gt;&gt;" href="#Base.:&gt;&gt;&gt;"><code>Base.:&gt;&gt;&gt;</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&gt;&gt;&gt;(x, n)</code></pre><p>Unsigned right bit shift operator, <code>x &gt;&gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p><p>For <a href="numbers.html#Core.Unsigned"><code>Unsigned</code></a> integer types, this is equivalent to <a href="math.html#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>. For <a href="numbers.html#Core.Signed"><code>Signed</code></a> integer types, this is equivalent to <code>signed(unsigned(x) &gt;&gt; n)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Int8(-14) &gt;&gt;&gt; 2
60

julia&gt; bits(Int8(-14))
&quot;11110010&quot;

julia&gt; bits(Int8(60))
&quot;00111100&quot;</code></pre><p><a href="numbers.html#Base.GMP.BigInt"><code>BigInt</code></a>s are treated as if having infinite size, so no filling is required and this is equivalent to <a href="math.html#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>.</p><p>See also <a href="math.html#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="math.html#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L575-L601">source</a><div><pre><code class="language-none">&gt;&gt;&gt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Unsigned right bitshift operator, <code>B &gt;&gt;&gt; n</code>. Equivalent to <code>B &gt;&gt; n</code>. See <a href="math.html#Base.:&gt;&gt;"><code>&gt;&gt;</code></a> for details and examples.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/bitarray.jl#L1461-L1466">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.colon" href="#Base.colon"><code>Base.colon</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">colon(start, [step], stop)</code></pre><p>Called by <code>:</code> syntax for constructing ranges.</p><pre><code class="language-julia-repl">julia&gt; colon(1, 2, 5)
1:2:5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/range.jl#L18-L27">source</a><div><pre><code class="language-none">:(start, [step], stop)</code></pre><p>Range operator. <code>a:b</code> constructs a range from <code>a</code> to <code>b</code> with a step size of 1, and <code>a:s:b</code> is similar but uses a step size of <code>s</code>. These syntaxes call the function <code>colon</code>. The colon is also used in indexing to select whole dimensions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/range.jl#L39-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.range" href="#Base.range"><code>Base.range</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">range(start, [step], length)</code></pre><p>Construct a range by length, given a starting value and optional step (defaults to 1).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/range.jl#L55-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.OneTo" href="#Base.OneTo"><code>Base.OneTo</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Base.OneTo(n)</code></pre><p>Define an <code>AbstractUnitRange</code> that behaves like <code>1:n</code>, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/range.jl#L166-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.StepRangeLen" href="#Base.StepRangeLen"><code>Base.StepRangeLen</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}
StepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}</code></pre><p>A range <code>r</code> where <code>r[i]</code> produces values of type <code>T</code> (in the second form, <code>T</code> is deduced automatically), parameterized by a <code>ref</code>erence value, a <code>step</code>, and the <code>len</code>gth. By default <code>ref</code> is the starting value <code>r[1]</code>, but alternatively you can supply it as the value of <code>r[offset]</code> for some other index <code>1 &lt;= offset &lt;= len</code>. In conjunction with <code>TwicePrecision</code> this can be used to implement ranges that are free of roundoff error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/range.jl#L181-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==" href="#Base.:=="><code>Base.:==</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">==(x, y)</code></pre><p>Generic equality operator, giving a single <a href="numbers.html#Core.Bool"><code>Bool</code></a> result. Falls back to <code>===</code>. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.</p><p>Follows IEEE semantics for floating-point numbers.</p><p>Collections should generally implement <code>==</code> by calling <code>==</code> recursively on all contents.</p><p>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L53-L67">source</a><div><pre><code class="language-none">==(a::AbstractString, b::AbstractString)</code></pre><p>Test whether two strings are equal character by character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &quot;abc&quot; == &quot;abc&quot;
true

julia&gt; &quot;abc&quot; == &quot;αβγ&quot;
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/strings/basic.jl#L158-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:!=" href="#Base.:!="><code>Base.:!=</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">!=(x, y)
≠(x,y)</code></pre><p>Not-equals comparison operator. Always gives the opposite answer as <code>==</code>. New types should generally not implement this, and rely on the fallback definition <code>!=(x,y) = !(x==y)</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 3 != 2
true

julia&gt; &quot;foo&quot; ≠ &quot;foo&quot;
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L142-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:!==" href="#Base.:!=="><code>Base.:!==</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">!==(x, y)
≢(x,y)</code></pre><p>Equivalent to <code>!(x === y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a ≢ b
true

julia&gt; a ≢ a
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L186-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;" href="#Base.:&lt;"><code>Base.:&lt;</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&lt;(x, y)</code></pre><p>Less-than comparison operator. New numeric types should implement this function for two arguments of the new type. Because of the behavior of floating-point NaN values, <code>&lt;</code> implements a partial order. Types with a canonical partial order should implement <code>&lt;</code>, and types with a canonical total order should implement <code>isless</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &lt; &#39;b&#39;
true

julia&gt; &quot;abc&quot; &lt; &quot;abd&quot;
true

julia&gt; 5 &lt; 3
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L206-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=" href="#Base.:&lt;="><code>Base.:&lt;=</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&lt;=(x, y)
≤(x,y)</code></pre><p>Less-than-or-equals comparison operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &lt;= &#39;b&#39;
true

julia&gt; 7 ≤ 7 ≤ 9
true

julia&gt; &quot;abc&quot; ≤ &quot;abc&quot;
true

julia&gt; 5 &lt;= 3
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L251-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;" href="#Base.:&gt;"><code>Base.:&gt;</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&gt;(x, y)</code></pre><p>Greater-than comparison operator. Generally, new types should implement <code>&lt;</code> instead of this function, and rely on the fallback definition <code>&gt;(x, y) = y &lt; x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &gt; &#39;b&#39;
false

julia&gt; 7 &gt; 3 &gt; 1
true

julia&gt; &quot;abc&quot; &gt; &quot;abd&quot;
false

julia&gt; 5 &gt; 3
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L228-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;=" href="#Base.:&gt;="><code>Base.:&gt;=</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&gt;=(x, y)
≥(x,y)</code></pre><p>Greater-than-or-equals comparison operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &gt;= &#39;b&#39;
false

julia&gt; 7 ≥ 7 ≥ 3
true

julia&gt; &quot;abc&quot; ≥ &quot;abc&quot;
true

julia&gt; 5 &gt;= 3
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L275-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cmp" href="#Base.cmp"><code>Base.cmp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cmp(x,y)</code></pre><p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. Uses the total order implemented by <code>isless</code>. For floating-point numbers, uses <code>&lt;</code> but throws an error for unordered arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cmp(1, 2)
-1

julia&gt; cmp(2, 1)
1

julia&gt; cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L320-L339">source</a><div><pre><code class="language-none">cmp(a::AbstractString, b::AbstractString)</code></pre><p>Compare two strings for equality.</p><p>Return <code>0</code> if both strings have the same length and the character at each index is the same in both strings. Return <code>-1</code> if <code>a</code> is a substring of <code>b</code>, or if <code>a</code> comes before <code>b</code> in alphabetical order. Return <code>1</code> if <code>b</code> is a substring of <code>a</code>, or if <code>b</code> comes before <code>a</code> in alphabetical order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cmp(&quot;abc&quot;, &quot;abc&quot;)
0

julia&gt; cmp(&quot;ab&quot;, &quot;abc&quot;)
-1

julia&gt; cmp(&quot;abc&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;ab&quot;, &quot;ac&quot;)
-1

julia&gt; cmp(&quot;ac&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;α&quot;, &quot;a&quot;)
1

julia&gt; cmp(&quot;b&quot;, &quot;β&quot;)
-1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/strings/basic.jl#L103-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:~" href="#Base.:~"><code>Base.:~</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">~(x)</code></pre><p>Bitwise not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ~4
-5

julia&gt; ~10
-11

julia&gt; ~true
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L244-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&amp;" href="#Base.:&amp;"><code>Base.:&amp;</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">&amp;(x, y)</code></pre><p>Bitwise and.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 4 &amp; 10
0

julia&gt; 4 &amp; 12
4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L263-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:|" href="#Base.:|"><code>Base.:|</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">|(x, y)</code></pre><p>Bitwise or.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 4 | 10
14

julia&gt; 4 | 1
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L279-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.xor" href="#Base.xor"><code>Base.xor</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">xor(x, y)
⊻(x, y)</code></pre><p>Bitwise exclusive or of <code>x</code> and <code>y</code>.  The infix operation <code>a ⊻ b</code> is a synonym for <code>xor(a,b)</code>, and <code>⊻</code> can be typed by tab-completing <code>\xor</code> or <code>\veebar</code> in the Julia REPL.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [true; true; false] .⊻ [true; false; false]
3-element BitArray{1}:
 false
  true
 false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/bool.jl#L45-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:!" href="#Base.:!"><code>Base.:!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">!(x)</code></pre><p>Boolean not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; !true
false

julia&gt; !false
true

julia&gt; .![true false true]
1×3 BitArray{2}:
 false  true  false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/bool.jl#L17-L34">source</a><div><pre><code class="language-none">!f::Function</code></pre><p>Predicate function negation: when the argument of <code>!</code> is a function, it returns a function which computes the boolean negation of <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; str = &quot;∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε&quot;
&quot;∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε&quot;

julia&gt; filter(isalpha, str)
&quot;εδxyδfxfyε&quot;

julia&gt; filter(!isalpha, str)
&quot;∀  &gt; 0, ∃  &gt; 0: |-| &lt;  ⇒ |()-()| &lt; &quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L956-L973">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="&amp;&amp;" href="#&amp;&amp;"><code>&amp;&amp;</code></a> — <span class="docstring-category">Keyword</span>.</div><div><pre><code class="language-none">x &amp;&amp; y</code></pre><p>Short-circuiting boolean AND.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L543-L547">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="||" href="#||"><code>||</code></a> — <span class="docstring-category">Keyword</span>.</div><div><pre><code class="language-none">x || y</code></pre><p>Short-circuiting boolean OR.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/docs/basedocs.jl#L550-L554">source</a></section><h2><a class="nav-anchor" id="Mathematical-Functions-1" href="#Mathematical-Functions-1">Mathematical Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isapprox(x, y; rtol::Real=atol&gt;0 ? √eps : 0, atol::Real=0, nans::Bool=false, norm::Function)</code></pre><p>Inexact equality comparison: <code>true</code> if <code>norm(x-y) &lt;= max(atol, rtol*max(norm(x), norm(y)))</code>. The default <code>atol</code> is zero and the default <code>rtol</code> depends on the types of <code>x</code> and <code>y</code>. The keyword argument <code>nans</code> determines whether or not NaN values are considered equal (defaults to false).</p><p>For real or complex floating-point values, if an <code>atol &gt; 0</code> is not specified, <code>rtol</code> defaults to the square root of <a href="dates.html#Base.eps"><code>eps</code></a> of the type of <code>x</code> or <code>y</code>, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an <code>atol &gt; 0</code> is supplied, <code>rtol</code> defaults to zero.</p><p><code>x</code> and <code>y</code> may also be arrays of numbers, in which case <code>norm</code> defaults to <code>vecnorm</code> but may be changed by passing a <code>norm::Function</code> keyword argument. (For numbers, <code>norm</code> is the same thing as <code>abs</code>.) When <code>x</code> and <code>y</code> are arrays, if <code>norm(x-y)</code> is not finite (i.e. <code>±Inf</code> or <code>NaN</code>), the comparison falls back to checking whether all elements of <code>x</code> and <code>y</code> are approximately equal component-wise.</p><p>The binary operator <code>≈</code> is equivalent to <code>isapprox</code> with the default arguments, and <code>x ≉ y</code> is equivalent to <code>!isapprox(x,y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 0.1 ≈ (0.1 - 1e-10)
true

julia&gt; isapprox(10, 11; atol = 2)
true

julia&gt; isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/floatfuncs.jl#L191-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sin" href="#Base.sin"><code>Base.sin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sin(x)</code></pre><p>Compute sine of <code>x</code>, where <code>x</code> is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L325-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cos" href="#Base.cos"><code>Base.cos</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cos(x)</code></pre><p>Compute cosine of <code>x</code>, where <code>x</code> is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L332-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sincos" href="#Base.Math.sincos"><code>Base.Math.sincos</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sincos(x)</code></pre><p>Compute sine and cosine of <code>x</code>, where <code>x</code> is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L449-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.tan" href="#Base.tan"><code>Base.tan</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tan(x)</code></pre><p>Compute tangent of <code>x</code>, where <code>x</code> is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L339-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sind" href="#Base.Math.sind"><code>Base.Math.sind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sind(x)</code></pre><p>Compute sine of <code>x</code>, where <code>x</code> is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L540-L542">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cosd" href="#Base.Math.cosd"><code>Base.Math.cosd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cosd(x)</code></pre><p>Compute cosine of <code>x</code>, where <code>x</code> is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L540-L542">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.tand" href="#Base.Math.tand"><code>Base.Math.tand</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tand(x)</code></pre><p>Compute tangent of <code>x</code>, where <code>x</code> is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L540-L542">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sinpi" href="#Base.Math.sinpi"><code>Base.Math.sinpi</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sinpi(x)</code></pre><p>Compute <span>$\sin(\pi x)$</span> more accurately than <code>sin(pi*x)</code>, especially for large <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L207-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cospi" href="#Base.Math.cospi"><code>Base.Math.cospi</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cospi(x)</code></pre><p>Compute <span>$\cos(\pi x)$</span> more accurately than <code>cos(pi*x)</code>, especially for large <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L270-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sinh" href="#Base.sinh"><code>Base.sinh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sinh(x)</code></pre><p>Compute hyperbolic sine of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L206-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cosh" href="#Base.cosh"><code>Base.cosh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cosh(x)</code></pre><p>Compute hyperbolic cosine of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L213-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.tanh" href="#Base.tanh"><code>Base.tanh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tanh(x)</code></pre><p>Compute hyperbolic tangent of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L220-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asin" href="#Base.asin"><code>Base.asin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asin(x)</code></pre><p>Compute the inverse sine of <code>x</code>, where the output is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L346-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.acos" href="#Base.acos"><code>Base.acos</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acos(x)</code></pre><p>Compute the inverse cosine of <code>x</code>, where the output is in radians</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L353-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atan" href="#Base.atan"><code>Base.atan</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atan(x)</code></pre><p>Compute the inverse tangent of <code>x</code>, where the output is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L227-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.atan2" href="#Base.Math.atan2"><code>Base.Math.atan2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atan2(y, x)</code></pre><p>Compute the inverse tangent of <code>y/x</code>, using the signs of both <code>x</code> and <code>y</code> to determine the quadrant of the return value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L529-L534">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asind" href="#Base.Math.asind"><code>Base.Math.asind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asind(x)</code></pre><p>Compute the inverse sine of <code>x</code>, where the output is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L550-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acosd" href="#Base.Math.acosd"><code>Base.Math.acosd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acosd(x)</code></pre><p>Compute the inverse cosine of <code>x</code>, where the output is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L550-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.atand" href="#Base.Math.atand"><code>Base.Math.atand</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atand(x)</code></pre><p>Compute the inverse tangent of <code>x</code>, where the output is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L550-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sec" href="#Base.Math.sec"><code>Base.Math.sec</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sec(x)</code></pre><p>Compute the secant of <code>x</code>, where <code>x</code> is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L426-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.csc" href="#Base.Math.csc"><code>Base.Math.csc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">csc(x)</code></pre><p>Compute the cosecant of <code>x</code>, where <code>x</code> is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L426-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cot" href="#Base.Math.cot"><code>Base.Math.cot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cot(x)</code></pre><p>Compute the cotangent of <code>x</code>, where <code>x</code> is in radians.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L426-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.secd" href="#Base.Math.secd"><code>Base.Math.secd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">secd(x)</code></pre><p>Compute the secant of <code>x</code>, where <code>x</code> is in degrees.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L436-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cscd" href="#Base.Math.cscd"><code>Base.Math.cscd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cscd(x)</code></pre><p>Compute the cosecant of <code>x</code>, where <code>x</code> is in degrees.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L436-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cotd" href="#Base.Math.cotd"><code>Base.Math.cotd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cotd(x)</code></pre><p>Compute the cotangent of <code>x</code>, where <code>x</code> is in degrees.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L436-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asec" href="#Base.Math.asec"><code>Base.Math.asec</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asec(x)</code></pre><p>Compute the inverse secant of <code>x</code>, where the output is in radians. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L450-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acsc" href="#Base.Math.acsc"><code>Base.Math.acsc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acsc(x)</code></pre><p>Compute the inverse cosecant of <code>x</code>, where the output is in radians. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L450-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acot" href="#Base.Math.acot"><code>Base.Math.acot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acot(x)</code></pre><p>Compute the inverse cotangent of <code>x</code>, where the output is in radians. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L450-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asecd" href="#Base.Math.asecd"><code>Base.Math.asecd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asecd(x)</code></pre><p>Compute the inverse secant of <code>x</code>, where the output is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L550-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acscd" href="#Base.Math.acscd"><code>Base.Math.acscd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acscd(x)</code></pre><p>Compute the inverse cosecant of <code>x</code>, where the output is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L550-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acotd" href="#Base.Math.acotd"><code>Base.Math.acotd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acotd(x)</code></pre><p>Compute the inverse cotangent of <code>x</code>, where the output is in degrees. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L550-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sech" href="#Base.Math.sech"><code>Base.Math.sech</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sech(x)</code></pre><p>Compute the hyperbolic secant of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L431-L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.csch" href="#Base.Math.csch"><code>Base.Math.csch</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">csch(x)</code></pre><p>Compute the hyperbolic cosecant of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L431-L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.coth" href="#Base.Math.coth"><code>Base.Math.coth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">coth(x)</code></pre><p>Compute the hyperbolic cotangent of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L431-L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asinh" href="#Base.asinh"><code>Base.asinh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asinh(x)</code></pre><p>Compute the inverse hyperbolic sine of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L234-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.acosh" href="#Base.acosh"><code>Base.acosh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acosh(x)</code></pre><p>Compute the inverse hyperbolic cosine of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L360-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atanh" href="#Base.atanh"><code>Base.atanh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atanh(x)</code></pre><p>Compute the inverse hyperbolic tangent of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L367-L371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asech" href="#Base.Math.asech"><code>Base.Math.asech</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asech(x)</code></pre><p>Compute the inverse hyperbolic secant of <code>x</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L453-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acsch" href="#Base.Math.acsch"><code>Base.Math.acsch</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acsch(x)</code></pre><p>Compute the inverse hyperbolic cosecant of <code>x</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L453-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acoth" href="#Base.Math.acoth"><code>Base.Math.acoth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acoth(x)</code></pre><p>Compute the inverse hyperbolic cotangent of <code>x</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L453-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sinc" href="#Base.Math.sinc"><code>Base.Math.sinc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sinc(x)</code></pre><p>Compute <span>$\sin(\pi x) / (\pi x)$</span> if <span>$x \neq 0$</span>, and <span>$1$</span> if <span>$x = 0$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L396-L400">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cosc" href="#Base.Math.cosc"><code>Base.Math.cosc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cosc(x)</code></pre><p>Compute <span>$\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$</span> if <span>$x \neq 0$</span>, and <span>$0$</span> if <span>$x = 0$</span>. This is the derivative of <code>sinc(x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/trig.jl#L407-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.deg2rad" href="#Base.Math.deg2rad"><code>Base.Math.deg2rad</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">deg2rad(x)</code></pre><p>Convert <code>x</code> from degrees to radians.</p><pre><code class="language-julia-repl">julia&gt; deg2rad(90)
1.5707963267948966</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L155-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.rad2deg" href="#Base.Math.rad2deg"><code>Base.Math.rad2deg</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rad2deg(x)</code></pre><p>Convert <code>x</code> from radians to degrees.</p><pre><code class="language-julia-repl">julia&gt; rad2deg(pi)
180.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L143-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.hypot" href="#Base.Math.hypot"><code>Base.Math.hypot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hypot(x, y)</code></pre><p>Compute the hypotenuse <span>$\sqrt{x^2+y^2}$</span> avoiding overflow and underflow.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 10^10;

julia&gt; hypot(a, a)
1.4142135623730951e10

julia&gt; √(a^2 + a^2) # a^2 overflows
ERROR: DomainError with -2.914184810805068e18:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
 [2] sqrt at ./math.jl:462 [inlined]
 [3] sqrt(::Int64) at ./math.jl:472</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L475-L495">source</a><div><pre><code class="language-none">hypot(x...)</code></pre><p>Compute the hypotenuse <span>$\sqrt{\sum x_i^2}$</span> avoiding overflow and underflow.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L522-L526">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log-Tuple{Any}" href="#Base.log-Tuple{Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">log(x)</code></pre><p>Compute the natural logarithm of <code>x</code>. Throws <a href="base.html#Core.DomainError"><code>DomainError</code></a> for negative <a href="numbers.html#Core.Real"><code>Real</code></a> arguments. Use complex negative arguments to obtain complex results.</p><p>There is an experimental variant in the <code>Base.Math.JuliaLibm</code> module, which is typically faster and more accurate.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L374-L382">source</a><div><pre><code class="language-none">log(A{T}::StridedMatrix{T})</code></pre><p>If <code>A</code> has no negative real eigenvalue, compute the principal matrix logarithm of <code>A</code>, i.e. the unique matrix <span>$X$</span> such that <span>$e^X = A$</span> and <span>$-\pi &lt; Im(\lambda) &lt; \pi$</span> for all the eigenvalues <span>$\lambda$</span> of <span>$X$</span>. If <code>A</code> has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used, if <code>A</code> is triangular an improved version of the inverse scaling and squaring method is employed (see <a href="#footnote-AH12">[AH12]</a> and <a href="#footnote-AHR13">[AHR13]</a>). For general matrices, the complex Schur form (<a href="linalg.html#Base.LinAlg.schur"><code>schur</code></a>) is computed and the triangular algorithm is used on the triangular factor.</p><div class="footnote" id="footnote-AH12"><a href="#footnote-AH12"><strong>[AH12]</strong></a><p>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse  scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. <a href="http://dx.doi.org/10.1137/110852553">doi:10.1137/110852553</a></p></div><div class="footnote" id="footnote-AHR13"><a href="#footnote-AHR13"><strong>[AHR13]</strong></a><p>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fréchet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. <a href="http://dx.doi.org/10.1137/120885991">doi:10.1137/120885991</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = 2.7182818 * eye(2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia&gt; log(A)
2×2 Symmetric{Float64,Array{Float64,2}}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/linalg/dense.jl#L567-L597">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log-Tuple{Number,Number}" href="#Base.log-Tuple{Number,Number}"><code>Base.log</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">log(b,x)</code></pre><p>Compute the base <code>b</code> logarithm of <code>x</code>. Throws <a href="base.html#Core.DomainError"><code>DomainError</code></a> for negative <a href="numbers.html#Core.Real"><code>Real</code></a> arguments.</p><pre><code class="language-julia-repl">julia&gt; log(4,8)
1.5

julia&gt; log(4,2)
0.5</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>b</code> is a power of 2 or 10, <a href="math.html#Base.log2"><code>log2</code></a> or <a href="math.html#Base.log10"><code>log10</code></a> should be used, as these will typically be faster and more accurate. For example,</p><pre><code class="language-julia-repl">julia&gt; log(100,1000000)
2.9999999999999996

julia&gt; log10(1000000)/2
3.0</code></pre></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L173-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log2" href="#Base.log2"><code>Base.log2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">log2(x)</code></pre><p>Compute the logarithm of <code>x</code> to base 2. Throws <a href="base.html#Core.DomainError"><code>DomainError</code></a> for negative <a href="numbers.html#Core.Real"><code>Real</code></a> arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; log2(4)
2.0

julia&gt; log2(10)
3.321928094887362</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L385-L399">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log10" href="#Base.log10"><code>Base.log10</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">log10(x)</code></pre><p>Compute the logarithm of <code>x</code> to base 10. Throws <a href="base.html#Core.DomainError"><code>DomainError</code></a> for negative <a href="numbers.html#Core.Real"><code>Real</code></a> arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; log10(100)
2.0

julia&gt; log10(2)
0.3010299956639812</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L402-L416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log1p" href="#Base.log1p"><code>Base.log1p</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">log1p(x)</code></pre><p>Accurate natural logarithm of <code>1+x</code>. Throws <a href="base.html#Core.DomainError"><code>DomainError</code></a> for <a href="numbers.html#Core.Real"><code>Real</code></a> arguments less than -1.</p><p>There is an experimental variant in the <code>Base.Math.JuliaLibm</code> module, which is typically faster and more accurate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; log1p(-0.5)
-0.6931471805599453

julia&gt; log1p(0)
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L419-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.frexp" href="#Base.Math.frexp"><code>Base.Math.frexp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">frexp(val)</code></pre><p>Return <code>(x,exp)</code> such that <code>x</code> has a magnitude in the interval <span>$[1/2, 1)$</span> or 0, and <code>val</code> is equal to <span>$x \times 2^{exp}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L657-L662">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp" href="#Base.exp"><code>Base.exp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">exp(x)</code></pre><p>Compute the natural base exponential of <code>x</code>, in other words <span>$e^x$</span>.</p><pre><code class="language-julia-repl">julia&gt; exp(1.0)
2.718281828459045</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/exp.jl#L62-L71">source</a><div><pre><code class="language-none">exp(A::AbstractMatrix)</code></pre><p>Compute the matrix exponential of <code>A</code>, defined by</p><div>\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]</div><p>For symmetric or Hermitian <code>A</code>, an eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used, otherwise the scaling and squaring algorithm (see <a href="#footnote-H05">[H05]</a>) is chosen.</p><div class="footnote" id="footnote-H05"><a href="#footnote-H05"><strong>[H05]</strong></a><p>Nicholas J. Higham, &quot;The squaring and scaling method for the matrix exponential revisited&quot;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. <a href="http://dx.doi.org/10.1137/090768539">doi:10.1137/090768539</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = eye(2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; exp(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/linalg/dense.jl#L437-L463">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp2" href="#Base.exp2"><code>Base.exp2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">exp2(x)</code></pre><p>Compute the base 2 exponential of <code>x</code>, in other words <span>$2^x$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp2(5)
32.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L274-L284">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp10" href="#Base.exp10"><code>Base.exp10</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">exp10(x)</code></pre><p>Compute the base 10 exponential of <code>x</code>, in other words <span>$10^x$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp10(2)
100.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L287-L297">source</a><div><pre><code class="language-none">exp10(x)</code></pre><p>Compute <span>$10^x$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp10(2)
100.0

julia&gt; exp10(0.2)
1.5848931924611136</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/exp10.jl#L70-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.ldexp" href="#Base.Math.ldexp"><code>Base.Math.ldexp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ldexp(x, n)</code></pre><p>Compute <span>$x \times 2^n$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ldexp(5., 2)
20.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L553-L563">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.modf" href="#Base.Math.modf"><code>Base.Math.modf</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modf(x)</code></pre><p>Return a tuple (fpart,ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; modf(3.5)
(0.5, 3.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L716-L727">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.expm1" href="#Base.expm1"><code>Base.expm1</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">expm1(x)</code></pre><p>Accurately compute <span>$e^x-1$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L241-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.round-Tuple{Type,Any}" href="#Base.round-Tuple{Type,Any}"><code>Base.round</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">round([T,] x, [digits, [base]], [r::RoundingMode])</code></pre><p>Rounds <code>x</code> to an integer value according to the provided <a href="math.html#Base.Rounding.RoundingMode"><code>RoundingMode</code></a>, returning a value of the same type as <code>x</code>. When not specifying a rounding mode the global mode will be used (see <a href="numbers.html#Base.Rounding.rounding"><code>rounding</code></a>), which by default is round to the nearest integer (<a href="math.html#Base.Rounding.RoundNearest"><code>RoundNearest</code></a> mode), with ties (fractional values of 0.5) being rounded to the nearest even integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; round(1.7)
2.0

julia&gt; round(1.5)
2.0

julia&gt; round(2.5)
2.0</code></pre><p>The optional <a href="math.html#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> argument will change how the number gets rounded.</p><p><code>round(T, x, [r::RoundingMode])</code> converts the result to type <code>T</code>, throwing an <a href="base.html#Core.InexactError"><code>InexactError</code></a> if the value is not representable.</p><p><code>round(x, digits)</code> rounds to the specified number of digits after the decimal place (or before if negative). <code>round(x, digits, base)</code> rounds using a base other than 10.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; round(pi, 2)
3.14

julia&gt; round(pi, 3, 2)
3.125</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the <a href="numbers.html#Core.Float64"><code>Float64</code></a> value represented by <code>1.15</code> is actually <em>less</em> than 1.15, yet will be rounded to 1.2.</p><h1>Examples</h1><pre><code class="language-julia-repl">julia&gt; x = 1.15
1.15

julia&gt; @sprintf &quot;%.20f&quot; x
&quot;1.14999999999999991118&quot;

julia&gt; x &lt; 115//100
true

julia&gt; round(x, 1)
1.2</code></pre></div></div><p>See also <a href="math.html#Base.signif"><code>signif</code></a> for rounding to significant digits.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/floatfuncs.jl#L40-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.RoundingMode" href="#Base.Rounding.RoundingMode"><code>Base.Rounding.RoundingMode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RoundingMode</code></pre><p>A type used for controlling the rounding mode of floating point operations (via <a href="numbers.html#Base.Rounding.rounding"><code>rounding</code></a>/<a href="numbers.html#Base.Rounding.setrounding-Tuple{Type,Any}"><code>setrounding</code></a> functions), or as optional arguments for rounding to the nearest integer (via the <a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a> function).</p><p>Currently supported rounding modes are:</p><ul><li><p><a href="math.html#Base.Rounding.RoundNearest"><code>RoundNearest</code></a> (default)</p></li><li><p><a href="math.html#Base.Rounding.RoundNearestTiesAway"><code>RoundNearestTiesAway</code></a></p></li><li><p><a href="math.html#Base.Rounding.RoundNearestTiesUp"><code>RoundNearestTiesUp</code></a></p></li><li><p><a href="math.html#Base.Rounding.RoundToZero"><code>RoundToZero</code></a></p></li><li><p><code>RoundFromZero</code> (<a href="numbers.html#Base.MPFR.BigFloat"><code>BigFloat</code></a> only)</p></li><li><p><a href="math.html#Base.Rounding.RoundUp"><code>RoundUp</code></a></p></li><li><p><a href="math.html#Base.Rounding.RoundDown"><code>RoundDown</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rounding.jl#L26-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.RoundNearest" href="#Base.Rounding.RoundNearest"><code>Base.Rounding.RoundNearest</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">RoundNearest</code></pre><p>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rounding.jl#L46-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.RoundNearestTiesAway" href="#Base.Rounding.RoundNearestTiesAway"><code>Base.Rounding.RoundNearestTiesAway</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">RoundNearestTiesAway</code></pre><p>Rounds to nearest integer, with ties rounded away from zero (C/C++ <a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a> behaviour).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rounding.jl#L77-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.RoundNearestTiesUp" href="#Base.Rounding.RoundNearestTiesUp"><code>Base.Rounding.RoundNearestTiesUp</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">RoundNearestTiesUp</code></pre><p>Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript <a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a> behaviour).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rounding.jl#L85-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.RoundToZero" href="#Base.Rounding.RoundToZero"><code>Base.Rounding.RoundToZero</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">RoundToZero</code></pre><p><a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a> using this rounding mode is an alias for <a href="math.html#Base.trunc"><code>trunc</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rounding.jl#L54-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.RoundUp" href="#Base.Rounding.RoundUp"><code>Base.Rounding.RoundUp</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">RoundUp</code></pre><p><a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a> using this rounding mode is an alias for <a href="math.html#Base.ceil"><code>ceil</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rounding.jl#L61-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.RoundDown" href="#Base.Rounding.RoundDown"><code>Base.Rounding.RoundDown</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">RoundDown</code></pre><p><a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a> using this rounding mode is an alias for <a href="math.html#Base.floor"><code>floor</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/rounding.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.round-Union{Tuple{MI}, Tuple{MR}, Tuple{T}, Tuple{Complex{T},RoundingMode{MR},RoundingMode{MI}}} where MI where MR where T&lt;:AbstractFloat" href="#Base.round-Union{Tuple{MI}, Tuple{MR}, Tuple{T}, Tuple{Complex{T},RoundingMode{MR},RoundingMode{MI}}} where MI where MR where T&lt;:AbstractFloat"><code>Base.round</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">round(z, RoundingModeReal, RoundingModeImaginary)</code></pre><p>Returns the nearest integral value of the same type as the complex-valued <code>z</code> to <code>z</code>, breaking ties using the specified <a href="math.html#Base.Rounding.RoundingMode"><code>RoundingMode</code></a>s. The first <a href="math.html#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> is used for rounding the real components while the second is used for rounding the imaginary components.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/complex.jl#L931-L938">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ceil" href="#Base.ceil"><code>Base.ceil</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ceil([T,] x, [digits, [base]])</code></pre><p><code>ceil(x)</code> returns the nearest integral value of the same type as <code>x</code> that is greater than or equal to <code>x</code>.</p><p><code>ceil(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p><p><code>digits</code> and <code>base</code> work as for <a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L561-L571">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.floor" href="#Base.floor"><code>Base.floor</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">floor([T,] x, [digits, [base]])</code></pre><p><code>floor(x)</code> returns the nearest integral value of the same type as <code>x</code> that is less than or equal to <code>x</code>.</p><p><code>floor(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p><p><code>digits</code> and <code>base</code> work as for <a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L548-L558">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.trunc" href="#Base.trunc"><code>Base.trunc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trunc([T,] x, [digits, [base]])</code></pre><p><code>trunc(x)</code> returns the nearest integral value of the same type as <code>x</code> whose absolute value is less than or equal to <code>x</code>.</p><p><code>trunc(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p><p><code>digits</code> and <code>base</code> work as for <a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L535-L545">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_trunc" href="#Base.unsafe_trunc"><code>Base.unsafe_trunc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unsafe_trunc(T, x)</code></pre><p><code>unsafe_trunc(T, x)</code> returns the nearest integral value of type <code>T</code> whose absolute value is less than or equal to <code>x</code>. If the value is not representable by <code>T</code>, an arbitrary value will be returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/float.jl#L283-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.signif" href="#Base.signif"><code>Base.signif</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">signif(x, digits, [base])</code></pre><p>Rounds (in the sense of <a href="dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round</code></a>) <code>x</code> so that there are <code>digits</code> significant digits, under a base <code>base</code> representation, default 10.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; signif(123.456, 2)
120.0

julia&gt; signif(357.913, 4, 2)
352.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/floatfuncs.jl#L138-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.min" href="#Base.min"><code>Base.min</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">min(x, y, ...)</code></pre><p>Return the minimum of the arguments. See also the <a href="collections.html#Base.minimum-Tuple{Any}"><code>minimum</code></a> function to take the minimum element from a collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; min(2, 5, 1)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L390-L401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.max" href="#Base.max"><code>Base.max</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">max(x, y, ...)</code></pre><p>Return the maximum of the arguments. See also the <a href="collections.html#Base.maximum-Tuple{Any}"><code>maximum</code></a> function to take the maximum element from a collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; max(2, 5, 1)
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L376-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.minmax" href="#Base.minmax"><code>Base.minmax</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">minmax(x, y)</code></pre><p>Return <code>(min(x,y), max(x,y))</code>. See also: <a href="collections.html#Base.extrema-Tuple{Any}"><code>extrema</code></a> that returns <code>(minimum(x), maximum(x))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; minmax(&#39;c&#39;,&#39;b&#39;)
(&#39;b&#39;, &#39;c&#39;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/operators.jl#L404-L414">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.clamp" href="#Base.Math.clamp"><code>Base.Math.clamp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">clamp(x, lo, hi)</code></pre><p>Return <code>x</code> if <code>lo &lt;= x &lt;= hi</code>. If <code>x &lt; lo</code>, return <code>lo</code>. If <code>x &gt; hi</code>, return <code>hi</code>. Arguments are promoted to a common type.</p><pre><code class="language-julia-repl">julia&gt; clamp.([pi, 1.0, big(10.)], 2., 9.)
3-element Array{BigFloat,1}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.000000000000000000000000000000000000000000000000000000000000000000000000000000
 9.000000000000000000000000000000000000000000000000000000000000000000000000000000</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L52-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.clamp!" href="#Base.Math.clamp!"><code>Base.Math.clamp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">clamp!(array::AbstractArray, lo, hi)</code></pre><p>Restrict values in <code>array</code> to the specified range, in-place. See also <a href="math.html#Base.Math.clamp"><code>clamp</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L72-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.abs" href="#Base.abs"><code>Base.abs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">abs(x)</code></pre><p>The absolute value of <code>x</code>.</p><p>When <code>abs</code> is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when <code>abs</code> is applied to the minimum representable value of a signed integer. That is, when <code>x == typemin(typeof(x))</code>, <code>abs(x) == x &lt; 0</code>, not <code>-x</code> as might be expected.</p><pre><code class="language-julia-repl">julia&gt; abs(-3)
3

julia&gt; abs(1 + im)
1.4142135623730951

julia&gt; abs(typemin(Int64))
-9223372036854775808</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/int.jl#L98-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_abs" href="#Base.Checked.checked_abs"><code>Base.Checked.checked_abs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_abs(x)</code></pre><p>Calculates <code>abs(x)</code>, checking for overflow errors where applicable. For example, standard two&#39;s complement signed integers (e.g. <code>Int</code>) cannot represent <code>abs(typemin(Int))</code>, thus leading to an overflow.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L109-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_neg" href="#Base.Checked.checked_neg"><code>Base.Checked.checked_neg</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_neg(x)</code></pre><p>Calculates <code>-x</code>, checking for overflow errors where applicable. For example, standard two&#39;s complement signed integers (e.g. <code>Int</code>) cannot represent <code>-typemin(Int)</code>, thus leading to an overflow.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L81-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_add" href="#Base.Checked.checked_add"><code>Base.Checked.checked_add</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_add(x, y)</code></pre><p>Calculates <code>x+y</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L160-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_sub" href="#Base.Checked.checked_sub"><code>Base.Checked.checked_sub</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_sub(x, y)</code></pre><p>Calculates <code>x-y</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L217-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_mul" href="#Base.Checked.checked_mul"><code>Base.Checked.checked_mul</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_mul(x, y)</code></pre><p>Calculates <code>x*y</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L282-L288">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_div" href="#Base.Checked.checked_div"><code>Base.Checked.checked_div</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_div(x, y)</code></pre><p>Calculates <code>div(x,y)</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L311-L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_rem" href="#Base.Checked.checked_rem"><code>Base.Checked.checked_rem</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_rem(x, y)</code></pre><p>Calculates <code>x%y</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L320-L326">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_fld" href="#Base.Checked.checked_fld"><code>Base.Checked.checked_fld</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_fld(x, y)</code></pre><p>Calculates <code>fld(x,y)</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L329-L335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_mod" href="#Base.Checked.checked_mod"><code>Base.Checked.checked_mod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_mod(x, y)</code></pre><p>Calculates <code>mod(x,y)</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L338-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.checked_cld" href="#Base.Checked.checked_cld"><code>Base.Checked.checked_cld</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.checked_cld(x, y)</code></pre><p>Calculates <code>cld(x,y)</code>, checking for overflow errors where applicable.</p><p>The overflow protection may impose a perceptible performance penalty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L347-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.add_with_overflow" href="#Base.Checked.add_with_overflow"><code>Base.Checked.add_with_overflow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.add_with_overflow(x, y) -&gt; (r, f)</code></pre><p>Calculates <code>r = x+y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L130-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.sub_with_overflow" href="#Base.Checked.sub_with_overflow"><code>Base.Checked.sub_with_overflow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.sub_with_overflow(x, y) -&gt; (r, f)</code></pre><p>Calculates <code>r = x-y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L192-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Checked.mul_with_overflow" href="#Base.Checked.mul_with_overflow"><code>Base.Checked.mul_with_overflow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Base.mul_with_overflow(x, y) -&gt; (r, f)</code></pre><p>Calculates <code>r = x*y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/checked.jl#L232-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.abs2" href="#Base.abs2"><code>Base.abs2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">abs2(x)</code></pre><p>Squared absolute value of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; abs2(-3)
9</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L124-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copysign" href="#Base.copysign"><code>Base.copysign</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">copysign(x, y) -&gt; z</code></pre><p>Return <code>z</code> which has the magnitude of <code>x</code> and the same sign as <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; copysign(1, -2)
-1

julia&gt; copysign(-1, 2)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L151-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sign" href="#Base.sign"><code>Base.sign</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sign(x)</code></pre><p>Return zero if <code>x==0</code> and <span>$x/|x|$</span> otherwise (i.e., ±1 for real <code>x</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L114-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.signbit" href="#Base.signbit"><code>Base.signbit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">signbit(x)</code></pre><p>Returns <code>true</code> if the value of the sign of <code>x</code> is negative, otherwise <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; signbit(-4)
true

julia&gt; signbit(5)
false

julia&gt; signbit(5.5)
false

julia&gt; signbit(-4.1)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L92-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.flipsign" href="#Base.flipsign"><code>Base.flipsign</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">flipsign(x, y)</code></pre><p>Return <code>x</code> with its sign flipped if <code>y</code> is negative. For example <code>abs(x) = flipsign(x,x)</code>.</p><pre><code class="language-julia-repl">julia&gt; flipsign(5, 3)
5

julia&gt; flipsign(5, -3)
-5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L136-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sqrt" href="#Base.sqrt"><code>Base.sqrt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqrt(x)</code></pre><p>Return <span>$\sqrt{x}$</span>. Throws <a href="base.html#Core.DomainError"><code>DomainError</code></a> for negative <a href="numbers.html#Core.Real"><code>Real</code></a> arguments. Use complex negative arguments instead. The prefix operator <code>√</code> is equivalent to <code>sqrt</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L467-L472">source</a><div><pre><code class="language-none">sqrt(A::AbstractMatrix)</code></pre><p>If <code>A</code> has no negative real eigenvalues, compute the principal matrix square root of <code>A</code>, that is the unique matrix <span>$X$</span> with eigenvalues having positive real part such that <span>$X^2 = A$</span>. Otherwise, a nonprincipal square root is returned.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method <a href="#footnote-BH83">[BH83]</a>, which computes the complex Schur form (<a href="linalg.html#Base.LinAlg.schur"><code>schur</code></a>) and then the complex square root of the triangular factor.</p><div class="footnote" id="footnote-BH83"><a href="#footnote-BH83"><strong>[BH83]</strong></a><p>Åke Björck and Sven Hammarling, &quot;A Schur method for the square root of a matrix&quot;, Linear Algebra and its Applications, 52-53, 1983, 127-140. <a href="http://dx.doi.org/10.1016/0024-3795(83)80010-X">doi:10.1016/0024-3795(83)80010-X</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia&gt; sqrt(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/linalg/dense.jl#L630-L660">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isqrt" href="#Base.isqrt"><code>Base.isqrt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isqrt(n::Integer)</code></pre><p>Integer square root: the largest integer <code>m</code> such that <code>m*m &lt;= n</code>.</p><pre><code class="language-julia-repl">julia&gt; isqrt(5)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L820-L829">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cbrt" href="#Base.Math.cbrt"><code>Base.Math.cbrt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cbrt(x::Real)</code></pre><p>Return the cube root of <code>x</code>, i.e. <span>$x^{1/3}$</span>. Negative values are accepted (returning the negative real root when <span>$x &lt; 0$</span>).</p><p>The prefix operator <code>∛</code> is equivalent to <code>cbrt</code>.</p><pre><code class="language-julia-repl">julia&gt; cbrt(big(27))
3.000000000000000000000000000000000000000000000000000000000000000000000000000000</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L259-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{Complex}" href="#Base.real-Tuple{Complex}"><code>Base.real</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">real(z)</code></pre><p>Return the real part of the complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; real(1 + 3im)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/complex.jl#L53-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.imag" href="#Base.imag"><code>Base.imag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imag(z)</code></pre><p>Return the imaginary part of the complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imag(1 + 3im)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/complex.jl#L66-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reim" href="#Base.reim"><code>Base.reim</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reim(z)</code></pre><p>Return both the real and imaginary parts of the complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reim(1 + 3im)
(1, 3)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/complex.jl#L81-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj" href="#Base.conj"><code>Base.conj</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">conj(z)</code></pre><p>Compute the complex conjugate of a complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; conj(1 + 3im)
1 - 3im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/complex.jl#L231-L241">source</a><div><pre><code class="language-none">conj(v::RowVector)</code></pre><p>Returns a <a href="linalg.html#Base.LinAlg.ConjArray"><code>ConjArray</code></a> lazy view of the input, where each element is conjugated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1+im, 1-im].&#39;
1×2 RowVector{Complex{Int64},Array{Complex{Int64},1}}:
 1+1im  1-1im

julia&gt; conj(v)
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/linalg/rowvector.jl#L88-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.angle" href="#Base.angle"><code>Base.angle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">angle(z)</code></pre><p>Compute the phase angle in radians of a complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rad2deg(angle(1 + im))
45.0

julia&gt; rad2deg(angle(1 - im))
-45.0

julia&gt; rad2deg(angle(-1 - im))
-135.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/complex.jl#L482-L498">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cis" href="#Base.cis"><code>Base.cis</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cis(z)</code></pre><p>Return <span>$\exp(iz)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cis(π) ≈ -1
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/complex.jl#L465-L475">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.binomial" href="#Base.binomial"><code>Base.binomial</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">binomial(n, k)</code></pre><p>Number of ways to choose <code>k</code> out of <code>n</code> items.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; binomial(5, 3)
10

julia&gt; factorial(5) ÷ (factorial(5-3) * factorial(3))
10</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L850-L863">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.factorial" href="#Base.factorial"><code>Base.factorial</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">factorial(n)</code></pre><p>Factorial of <code>n</code>. If <code>n</code> is an <a href="numbers.html#Core.Integer"><code>Integer</code></a>, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if <code>n</code> is not small, but you can use <code>factorial(big(n))</code> to compute the result exactly in arbitrary precision. If <code>n</code> is not an <code>Integer</code>, <code>factorial(n)</code> is equivalent to <a href="math.html#Base.Math.gamma"><code>gamma(n+1)</code></a>.</p><pre><code class="language-julia-repl">julia&gt; factorial(6)
720

julia&gt; factorial(21)
ERROR: OverflowError: 21 is too large to look up in the table
Stacktrace:
 [1] factorial_lookup at ./combinatorics.jl:19 [inlined]
 [2] factorial(::Int64) at ./combinatorics.jl:27

julia&gt; factorial(21.0)
5.109094217170944e19

julia&gt; factorial(big(21))
51090942171709440000</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L297-L321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.gcd" href="#Base.gcd"><code>Base.gcd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gcd(x,y)</code></pre><p>Greatest common (positive) divisor (or zero if <code>x</code> and <code>y</code> are both zero).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; gcd(6,9)
3

julia&gt; gcd(6,-9)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L5-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lcm" href="#Base.lcm"><code>Base.lcm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lcm(x,y)</code></pre><p>Least common (non-negative) multiple.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lcm(2,3)
6

julia&gt; lcm(-2,3)
6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L52-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.gcdx" href="#Base.gcdx"><code>Base.gcdx</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gcdx(x,y)</code></pre><p>Computes the greatest common (positive) divisor of <code>x</code> and <code>y</code> and their Bézout coefficients, i.e. the integer coefficients <code>u</code> and <code>v</code> that satisfy <span>$ux+vy = d = gcd(x,y)$</span>. <span>$gcdx(x,y)$</span> returns <span>$(d,u,v)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; gcdx(12, 42)
(6, -3, 1)

julia&gt; gcdx(240, 46)
(2, -9, 47)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Bézout coefficients are <em>not</em> uniquely defined. <code>gcdx</code> returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients <code>u</code> and <code>v</code> are minimal in the sense that <span>$|u| &lt; |y/d|$</span> and <span>$|v| &lt; |x/d|$</span>. Furthermore, the signs of <code>u</code> and <code>v</code> are chosen so that <code>d</code> is positive. For unsigned integers, the coefficients <code>u</code> and <code>v</code> might be near their <code>typemax</code>, and the identity then holds only via the unsigned integers&#39; modulo arithmetic.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L86-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ispow2" href="#Base.ispow2"><code>Base.ispow2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ispow2(n::Integer) -&gt; Bool</code></pre><p>Test whether <code>n</code> is a power of two.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ispow2(4)
true

julia&gt; ispow2(5)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L324-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.nextpow2" href="#Base.nextpow2"><code>Base.nextpow2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nextpow2(n::Integer)</code></pre><p>The smallest power of two not less than <code>n</code>. Returns 0 for <code>n==0</code>, and returns <code>-nextpow2(-n)</code> for negative arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nextpow2(16)
16

julia&gt; nextpow2(17)
32</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L288-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.prevpow2" href="#Base.prevpow2"><code>Base.prevpow2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">prevpow2(n::Integer)</code></pre><p>The largest power of two not greater than <code>n</code>. Returns 0 for <code>n==0</code>, and returns <code>-prevpow2(-n)</code> for negative arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prevpow2(5)
4

julia&gt; prevpow2(0)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L306-L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.nextpow" href="#Base.nextpow"><code>Base.nextpow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nextpow(a, x)</code></pre><p>The smallest <code>a^n</code> not less than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must be greater than 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nextpow(2, 7)
8

julia&gt; nextpow(2, 9)
16

julia&gt; nextpow(5, 20)
25

julia&gt; nextpow(4, 16)
16</code></pre><p>See also <a href="math.html#Base.prevpow"><code>prevpow</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L340-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.prevpow" href="#Base.prevpow"><code>Base.prevpow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">prevpow(a, x)</code></pre><p>The largest <code>a^n</code> not greater than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must not be less than 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prevpow(2, 7)
4

julia&gt; prevpow(2, 9)
8

julia&gt; prevpow(5, 20)
5

julia&gt; prevpow(4, 16)
16</code></pre><p>See also <a href="math.html#Base.nextpow"><code>nextpow</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L373-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.nextprod" href="#Base.nextprod"><code>Base.nextprod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nextprod([k_1, k_2,...], n)</code></pre><p>Next integer greater than or equal to <code>n</code> that can be written as <span>$\prod k_i^{p_i}$</span> for integers <span>$p_1$</span>, <span>$p_2$</span>, etc.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nextprod([2, 3], 105)
108

julia&gt; 2^2 * 3^3
108</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/combinatorics.jl#L222-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.invmod" href="#Base.invmod"><code>Base.invmod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">invmod(x,m)</code></pre><p>Take the inverse of <code>x</code> modulo <code>m</code>: <code>y</code> such that <span>$x y = 1 \pmod m$</span>, with <span>$div(x,y) = 0$</span>. This is undefined for <span>$m = 0$</span>, or if <span>$gcd(x,m) \neq 1$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; invmod(2,5)
3

julia&gt; invmod(2,3)
2

julia&gt; invmod(5,6)
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L130-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.powermod" href="#Base.powermod"><code>Base.powermod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">powermod(x::Integer, p::Integer, m)</code></pre><p>Compute <span>$x^p \pmod m$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; powermod(2, 6, 5)
4

julia&gt; mod(2^6, 5)
4

julia&gt; powermod(5, 2, 20)
5

julia&gt; powermod(5, 2, 19)
6

julia&gt; powermod(5, 3, 19)
11</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L239-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.gamma" href="#Base.Math.gamma"><code>Base.Math.gamma</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gamma(x)</code></pre><p>Compute the gamma function of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/gamma.jl#L6-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.lgamma" href="#Base.Math.lgamma"><code>Base.Math.lgamma</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lgamma(x)</code></pre><p>Compute the logarithm of the absolute value of <a href="math.html#Base.Math.gamma"><code>gamma</code></a> for <a href="numbers.html#Core.Real"><code>Real</code></a> <code>x</code>, while for <a href="numbers.html#Base.Complex"><code>Complex</code></a> <code>x</code> compute the principal branch cut of the logarithm of <code>gamma(x)</code> (defined for negative <code>real(x)</code> by analytic continuation from positive <code>real(x)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/gamma.jl#L36-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.lfact" href="#Base.Math.lfact"><code>Base.Math.lfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lfact(x)</code></pre><p>Compute the logarithmic factorial of a nonnegative integer <code>x</code>. Equivalent to <a href="math.html#Base.Math.lgamma"><code>lgamma</code></a> of <code>x + 1</code>, but <code>lgamma</code> extends this function to non-integer <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/gamma.jl#L27-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.beta" href="#Base.Math.beta"><code>Base.Math.beta</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">beta(x, y)</code></pre><p>Euler integral of the first kind <span>$\operatorname{B}(x,y) = \Gamma(x)\Gamma(y)/\Gamma(x+y)$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/gamma.jl#L139-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.lbeta" href="#Base.Math.lbeta"><code>Base.Math.lbeta</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lbeta(x, y)</code></pre><p>Natural logarithm of the absolute value of the <a href="math.html#Base.Math.beta"><code>beta</code></a> function <span>$\log(|\operatorname{B}(x,y)|)$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/special/gamma.jl#L151-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ndigits" href="#Base.ndigits"><code>Base.ndigits</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ndigits(n::Integer, b::Integer=10)</code></pre><p>Compute the number of digits in integer <code>n</code> written in base <code>b</code>. The base <code>b</code> must not be in <code>[-1, 0, 1]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ndigits(12345)
5

julia&gt; ndigits(1022, 16)
3

julia&gt; base(16, 1022)
&quot;3fe&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/intfuncs.jl#L521-L538">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.widemul" href="#Base.widemul"><code>Base.widemul</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">widemul(x, y)</code></pre><p>Multiply <code>x</code> and <code>y</code>, giving the result as a larger type.</p><pre><code class="language-julia-repl">julia&gt; widemul(Float32(3.), 4.)
1.200000000000000000000000000000000000000000000000000000000000000000000000000000e+01</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/number.jl#L199-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.@evalpoly" href="#Base.Math.@evalpoly"><code>Base.Math.@evalpoly</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@evalpoly(z, c...)</code></pre><p>Evaluate the polynomial <span>$\sum_k c[k] z^{k-1}$</span> for the coefficients <code>c[1]</code>, <code>c[2]</code>, ...; that is, the coefficients are given in ascending order by power of <code>z</code>.  This macro expands to efficient inline code that uses either Horner&#39;s method or, for complex <code>z</code>, a more efficient Goertzel-like algorithm.</p><pre><code class="language-julia-repl">julia&gt; @evalpoly(3, 1, 0, 1)
10

julia&gt; @evalpoly(2, 1, 0, 1)
5

julia&gt; @evalpoly(2, 1, 1, 1)
7</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/math.jl#L99-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.FastMath.@fastmath" href="#Base.FastMath.@fastmath"><code>Base.FastMath.@fastmath</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@fastmath expr</code></pre><p>Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined – be careful when doing this, as it may change numerical results.</p><p>This sets the <a href="http://llvm.org/docs/LangRef.html#fast-math-flags">LLVM Fast-Math flags</a>, and corresponds to the <code>-ffast-math</code> option in clang. See <a href="../manual/performance-tips.html#man-performance-annotations-1">the notes on performance annotations</a> for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @fastmath 1+2
3

julia&gt; @fastmath(sin(3))
0.1411200080598672</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/fastmath.jl#L128-L148">source</a></section><h2><a class="nav-anchor" id="Statistics-1" href="#Statistics-1">Statistics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mean" href="#Base.mean"><code>Base.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mean(f::Function, v)</code></pre><p>Apply the function <code>f</code> to each element of <code>v</code> and take the mean.</p><pre><code class="language-julia-repl">julia&gt; mean(√, [1, 2, 3])
1.3820881233139908

julia&gt; mean([√1, √2, √3])
1.3820881233139908</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L5-L17">source</a><div><pre><code class="language-none">mean(v[, region])</code></pre><p>Compute the mean of whole array <code>v</code>, or optionally along the dimensions in <code>region</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L66-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mean!" href="#Base.mean!"><code>Base.mean!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mean!(r, v)</code></pre><p>Compute the mean of <code>v</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; mean!([1., 1.], v)
2-element Array{Float64,1}:
 1.5
 3.5

julia&gt; mean!([1. 1.], v)
1×2 Array{Float64,2}:
 2.0  3.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L38-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.std" href="#Base.std"><code>Base.std</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">std(v[, region]; corrected::Bool=true, mean=nothing)</code></pre><p>Compute the sample standard deviation of a vector or array <code>v</code>, optionally along dimensions in <code>region</code>. The algorithm returns an estimator of the generative distribution&#39;s standard deviation under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sqrt(sum((v - mean(v)).^2) / (length(v) - 1))</code>. A pre-computed <code>mean</code> may be provided. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L264-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.stdm" href="#Base.stdm"><code>Base.stdm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stdm(v, m::Number; corrected::Bool=true)</code></pre><p>Compute the sample standard deviation of a vector <code>v</code> with known mean <code>m</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L286-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.var" href="#Base.var"><code>Base.var</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">var(v[, region]; corrected::Bool=true, mean=nothing)</code></pre><p>Compute the sample variance of a vector or array <code>v</code>, optionally along dimensions in <code>region</code>. The algorithm will return an estimator of the generative distribution&#39;s variance under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sum(abs2, v - mean(v)) / (length(v) - 1)</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>. The mean <code>mean</code> over the region may be provided.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L203-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.varm" href="#Base.varm"><code>Base.varm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">varm(v, m[, region]; corrected::Bool=true)</code></pre><p>Compute the sample variance of a collection <code>v</code> with known mean(s) <code>m</code>, optionally over <code>region</code>. <code>m</code> may contain means for each dimension of <code>v</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L183-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.middle" href="#Base.middle"><code>Base.middle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">middle(x)</code></pre><p>Compute the middle of a scalar value, which is equivalent to <code>x</code> itself, but of the type of <code>middle(x, x)</code> for consistency.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L535-L539">source</a><div><pre><code class="language-none">middle(x, y)</code></pre><p>Compute the middle of two reals <code>x</code> and <code>y</code>, which is equivalent in both value and type to computing their mean (<code>(x + y) / 2</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L545-L550">source</a><div><pre><code class="language-none">middle(range)</code></pre><p>Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.</p><pre><code class="language-julia-repl">julia&gt; middle(1:10)
5.5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L553-L563">source</a><div><pre><code class="language-none">middle(a)</code></pre><p>Compute the middle of an array <code>a</code>, which consists of finding its extrema and then computing their mean.</p><pre><code class="language-julia-repl">julia&gt; a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia&gt; middle(a)
5.95</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L566-L583">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.median" href="#Base.median"><code>Base.median</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">median(v[, region])</code></pre><p>Compute the median of an entire array <code>v</code>, or, optionally, along the dimensions in <code>region</code>. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L611-L622">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.median!" href="#Base.median!"><code>Base.median!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">median!(v)</code></pre><p>Like <a href="math.html#Base.median"><code>median</code></a>, but may overwrite the input vector.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L586-L590">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.quantile" href="#Base.quantile"><code>Base.quantile</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">quantile(v, p; sorted=false)</code></pre><p>Compute the quantile(s) of a vector <code>v</code> at a specified probability or vector or tuple of probabilities <code>p</code>. The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted.</p><p>The <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p><p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended. <code>quantile</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array.</p></div></div><ul><li><p>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L722-L742">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.quantile!" href="#Base.quantile!"><code>Base.quantile!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">quantile!([q, ] v, p; sorted=false)</code></pre><p>Compute the quantile(s) of a vector <code>v</code> at the probability or probabilities <code>p</code>, which can be given as a single value, a vector, or a tuple. If <code>p</code> is a vector, an optional output array <code>q</code> may also be specified. (If not provided, a new output array is created.) The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted; if <code>false</code> (the default), then the elements of <code>v</code> may be partially sorted.</p><p>The elements of <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p><p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended. <code>quantile!</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array.</p></div></div><ul><li><p>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L627-L650">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cov" href="#Base.cov"><code>Base.cov</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cov(x::AbstractVector; corrected::Bool=true)</code></pre><p>Compute the variance of the vector <code>x</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L363-L368">source</a><div><pre><code class="language-none">cov(X::AbstractMatrix[, vardim::Int=1]; corrected::Bool=true)</code></pre><p>Compute the covariance matrix of the matrix <code>X</code> along the dimension <code>vardim</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, vardim)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L371-L377">source</a><div><pre><code class="language-none">cov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)</code></pre><p>Compute the covariance between the vectors <code>x</code> and <code>y</code>. If <code>corrected</code> is <code>true</code> (the default), computes <span>$\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$</span> where <span>$*$</span> denotes the complex conjugate and <code>n = length(x) = length(y)</code>. If <code>corrected</code> is <code>false</code>, computes <span>$\frac{1}{n}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L381-L388">source</a><div><pre><code class="language-none">cov(X::AbstractVecOrMat, Y::AbstractVecOrMat[, vardim::Int=1]; corrected::Bool=true)</code></pre><p>Compute the covariance between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>vardim</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, vardim) = size(Y, vardim)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L392-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cor" href="#Base.cor"><code>Base.cor</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cor(x::AbstractVector)</code></pre><p>Return the number one.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L504-L508">source</a><div><pre><code class="language-none">cor(X::AbstractMatrix[, vardim::Int=1])</code></pre><p>Compute the Pearson correlation matrix of the matrix <code>X</code> along the dimension <code>vardim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L511-L515">source</a><div><pre><code class="language-none">cor(x::AbstractVector, y::AbstractVector)</code></pre><p>Compute the Pearson correlation between the vectors <code>x</code> and <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L518-L522">source</a><div><pre><code class="language-none">cor(X::AbstractVecOrMat, Y::AbstractVecOrMat[, vardim=1])</code></pre><p>Compute the Pearson correlation between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>vardim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d2ed8f47a938ceaa85417fc916d1512382bbde42/base/statistics.jl#L525-L529">source</a></section><footer><hr/><a class="previous" href="collections.html"><span class="direction">Previous</span><span class="title">Collections and Data Structures</span></a><a class="next" href="numbers.html"><span class="direction">Next</span><span class="title">Numbers</span></a></footer></article></body></html>
